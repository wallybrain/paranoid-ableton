---
phase: 04-midi-clip-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/helpers.js
  - src/tools/clip.js
  - src/tools/registry.js
autonomous: true

must_haves:
  truths:
    - "Claude can create a MIDI clip on any MIDI track in an empty clip slot"
    - "Claude can add notes to a MIDI clip with pitch, start_time, duration, velocity, and mute"
    - "Claude can remove notes from a MIDI clip by pitch range and/or time range"
    - "Claude can read existing note data from a MIDI clip as structured JSON objects"
    - "Claude can set loop start, loop end, and looping toggle on a clip"
    - "Claude can get clip properties including name, length, loop points, and note count"
    - "Claude can delete a clip from a clip slot"
  artifacts:
    - path: "src/tools/clip.js"
      provides: "MIDI clip editing domain module (7-8 tools)"
      exports: ["tools", "handle"]
    - path: "src/tools/helpers.js"
      provides: "Note serialization, validation, clip snapshot builder (additions to existing file)"
      exports: ["notesToFlatArray", "flatArrayToNotes", "validateNote", "buildClipSnapshot"]
    - path: "src/tools/registry.js"
      provides: "Clip module registered in domain modules array"
      contains: "import * as clip"
  key_links:
    - from: "src/tools/clip.js"
      to: "src/tools/helpers.js"
      via: "imports note helpers, clip snapshot, resolveTrackIndex, guardWrite"
      pattern: "import.*from.*helpers"
    - from: "src/tools/clip.js"
      to: "src/tools/shared.js"
      via: "ensureConnected() for lazy OscClient access"
      pattern: "ensureConnected"
    - from: "src/tools/clip.js"
      to: "src/osc-client.js"
      via: "TIMEOUTS import for OSC call timeouts"
      pattern: "TIMEOUTS"
    - from: "src/tools/registry.js"
      to: "src/tools/clip.js"
      via: "import * as clip, added to modules array"
      pattern: "import \\* as clip"
    - from: "src/tools/clip.js"
      to: "src/tools/scene.js"
      via: "ROUTING EXCLUSION: clip.js returns null for clip_launch and clip_stop (handled by scene.js)"
      pattern: "clip_launch.*clip_stop"
---

<objective>
Implement the complete MIDI clip editing module: note serialization helpers, clip domain module with 7-8 MCP tools, and registry wiring.

Purpose: This is the sole plan for Phase 4, delivering all four MIDI requirements (MIDI-01 through MIDI-04). The research provides complete tool designs, OSC address mappings, and code examples. The work follows established domain module patterns from Phase 3.

Output: Working clip.js module registered in the tool registry, enabling Claude to create/delete clips, add/remove/read notes, and control loop properties.
</objective>

<execution_context>
@/home/lwb3/.claude/get-shit-done/workflows/execute-plan.md
@/home/lwb3/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/lwb3/ableton-mcp/.planning/PROJECT.md
@/home/lwb3/ableton-mcp/.planning/ROADMAP.md
@/home/lwb3/ableton-mcp/.planning/STATE.md
@/home/lwb3/ableton-mcp/.planning/phases/04-midi-clip-editing/04-RESEARCH.md
@/home/lwb3/ableton-mcp/src/tools/helpers.js
@/home/lwb3/ableton-mcp/src/tools/scene.js
@/home/lwb3/ableton-mcp/src/tools/registry.js
@/home/lwb3/ableton-mcp/src/tools/shared.js
@/home/lwb3/ableton-mcp/src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add note serialization, validation, and clip snapshot helpers to helpers.js</name>
  <files>src/tools/helpers.js</files>
  <action>
Add the following exports to the EXISTING `src/tools/helpers.js` file. Append these after the existing `clearAllPendingDeletes` function. Do NOT modify any existing code in the file.

**Note serialization (structured JSON <-> flat OSC array):**

- `notesToFlatArray(notes)` -- converts array of note objects to AbletonOSC flat array format. Each note has {pitch, start_time, duration, velocity, mute}. Output is `[pitch, start_time, duration, velocity, mute_int, pitch, start_time, ...]` with 5 values per note. Velocity defaults to 100 if undefined. Mute converts boolean to 0/1 integer (default 0).

- `flatArrayToNotes(flat)` -- converts flat array (after stripping the 2-element track_index/clip_index prefix) back to structured note objects. Iterates in chunks of 5. Returns array of `{pitch, start_time, duration, velocity, mute: boolean}`. Returns empty array if flat array is empty.

**Note validation:**

- `validateNote(note, index)` -- validates a single note object. Checks:
  - `pitch` is integer 0-127 (required). Error: `INVALID_NOTE[${index}]: pitch must be integer 0-127, got ${value}`
  - `start_time` is number >= 0.0 (required). Error: `INVALID_NOTE[${index}]: start_time must be >= 0, got ${value}`
  - `duration` is number > 0.0 (required). Error: `INVALID_NOTE[${index}]: duration must be > 0, got ${value}`
  - `velocity` if provided, must be integer 1-127. Error: `INVALID_NOTE[${index}]: velocity must be 1-127, got ${value}`
  - Returns null if valid, throws Error with message if invalid.

- `validateNotes(notes)` -- validates an array of notes. Calls validateNote for each. Throws on first invalid note. If array is empty, throws `INVALID_NOTES: notes array must not be empty`.

**Clip snapshot builder:**

- `buildClipSnapshot(client, trackIndex, clipIndex)` -- async function that queries clip properties via OSC and returns a structured object. CRITICAL: clip responses prepend [track_index, clip_index, value], so destructure as `const [, , value] = await client.query(...)`.

  Queries (all using TIMEOUTS.QUERY):
  - `/live/clip/get/name` -> name (string)
  - `/live/clip/get/length` -> length (float, beats)
  - `/live/clip/get/loop_start` -> loop_start (float)
  - `/live/clip/get/loop_end` -> loop_end (float)
  - `/live/clip/get/looping` -> looping (int 0/1, convert to boolean)
  - `/live/clip/get/is_midi_clip` -> is_midi (int 0/1, convert to boolean)
  - `/live/clip/get/notes` -> note data (for note_count only)

  For the note count: query get/notes with just [trackIndex, clipIndex], slice off first 2 values, divide remaining length by 5.

  Returns: `{track_index, clip_index, name, length, loop_start, loop_end, looping, is_midi, note_count}`.

  Import TIMEOUTS from '../osc-client.js' at the top of helpers.js (add to existing imports if any, or add as new import). Note: helpers.js currently has NO imports -- this will be the first. Use: `import { TIMEOUTS } from '../osc-client.js';`
  </action>
  <verify>
Run: `node -e "import('./src/tools/helpers.js').then(h => { const flat = h.notesToFlatArray([{pitch:60,start_time:0,duration:0.5,velocity:100,mute:false}]); console.log('flat:', flat); const notes = h.flatArrayToNotes(flat); console.log('notes:', JSON.stringify(notes)); h.validateNotes([{pitch:60,start_time:0,duration:0.5}]); console.log('validation OK'); console.log('buildClipSnapshot type:', typeof h.buildClipSnapshot); console.log('OK'); })"`

Expected: flat is [60, 0, 0.5, 100, 0], notes round-trips back, validation passes, buildClipSnapshot is a function, ends with OK.
  </verify>
  <done>helpers.js exports notesToFlatArray, flatArrayToNotes, validateNote, validateNotes, and buildClipSnapshot. Note serialization correctly converts between structured JSON and 5-value flat arrays. Validation catches invalid pitch/start_time/duration/velocity ranges.</done>
</task>

<task type="auto">
  <name>Task 2: Create clip.js domain module with all MIDI clip tools</name>
  <files>src/tools/clip.js</files>
  <action>
Create `src/tools/clip.js` following the exact pattern from scene.js (export `tools[]` and `async handle(name, args)`).

**Imports:**
```javascript
import { ensureConnected } from './shared.js';
import { resolveTrackIndex, guardWrite, notesToFlatArray, flatArrayToNotes, validateNotes, buildClipSnapshot } from './helpers.js';
import { TIMEOUTS } from '../osc-client.js';
```

**Helper functions (module-internal):**

- `jsonResponse(data)` -- returns `{content: [{type: 'text', text: JSON.stringify(data)}]}`
- `errorResponse(message)` -- returns `{content: [{type: 'text', text: 'CLIP_ERROR: ' + message}], isError: true}`

**CRITICAL routing rule:** The handle function MUST return null for `clip_launch` and `clip_stop` because those are handled by scene.js. Check at the top of handle: `if (name === 'clip_launch' || name === 'clip_stop') return null;`

**Tool definitions (7-8 tools):**

1. **`clip_create`** (write, MIDI-01):
   - Description: "Create a new empty MIDI clip in a clip slot. Length is in beats (e.g., 4.0 = one bar at 4/4). Can only create on MIDI tracks in empty slots."
   - inputSchema properties: `track` (description: "Track index (0-based) or name"), `scene` (type: integer, description: "0-based scene/clip slot index"), `length` (type: number, description: "Clip length in beats (default 4.0)"), `name` (type: string, description: "Optional clip name")
   - Required: ['track', 'scene']
   - Handler: guardWrite, resolve track index, then:
     1. Check MIDI track: `const [, , hasMidi] = await client.query('/live/track/get/has_midi_input', [trackIndex]);` If !hasMidi, return errorResponse with INVALID_TRACK message.
     2. Check empty slot: `const response = await client.query('/live/clip_slot/get/has_clip', [trackIndex, args.scene]);` then `const hasClip = response[2];` If hasClip, return errorResponse with SLOT_NOT_EMPTY message.
     3. Create clip: `await client.query('/live/clip_slot/create_clip', [trackIndex, args.scene, args.length || 4.0], TIMEOUTS.COMMAND);`
     4. If args.name provided: `await client.query('/live/clip/set/name', [trackIndex, args.scene, args.name], TIMEOUTS.COMMAND);`
     5. Return buildClipSnapshot(client, trackIndex, args.scene).

2. **`clip_delete`** (write, MIDI-01):
   - Description: "Delete a clip from a clip slot."
   - inputSchema: track, scene (both required)
   - Handler: guardWrite, resolve track, delete via `/live/clip_slot/delete_clip` with [trackIndex, args.scene] and TIMEOUTS.COMMAND. Return `{deleted: true, track_index: trackIndex, clip_index: args.scene}`.

3. **`clip_get`** (read, MIDI-03/MIDI-04):
   - Description: "Get clip properties including name, length, loop points, whether it is a MIDI clip, and note count."
   - inputSchema: track, scene (both required)
   - Handler: resolve track, return buildClipSnapshot(client, trackIndex, args.scene).

4. **`clip_set_name`** (write, MIDI-01 polish):
   - Description: "Set the name of a clip."
   - inputSchema: track, scene, name (string, required)
   - Handler: guardWrite, resolve track, set via `/live/clip/set/name` with [trackIndex, args.scene, args.name] and TIMEOUTS.COMMAND. Return buildClipSnapshot.

5. **`clip_add_notes`** (write, MIDI-02):
   - Description: "Add MIDI notes to an existing clip. Each note needs pitch (0-127, 60=C4 middle C), start_time (beats from clip start), duration (beats), velocity (1-127, default 100), and mute (default false). Notes are added to existing content -- they do not replace."
   - inputSchema: track, scene, notes (array of objects with pitch/start_time/duration/velocity/mute). Required: ['track', 'scene', 'notes'].
   - Handler: guardWrite, resolve track, validateNotes(args.notes), convert via notesToFlatArray(args.notes), then send. For large note batches (>100 notes), chunk into batches of 100 and send multiple OSC messages. Use: `await client.query('/live/clip/add/notes', [trackIndex, args.scene, ...flatChunk], TIMEOUTS.COMMAND);` for each chunk. Return buildClipSnapshot with added `{notes_added: args.notes.length}`.

6. **`clip_remove_notes`** (write, MIDI-02):
   - Description: "Remove MIDI notes from a clip by pitch and/or time range. WARNING: Omitting all filter parameters removes ALL notes from the clip."
   - inputSchema: track, scene (required), pitch_start (integer, "Minimum pitch, default 0"), pitch_span (integer, "Number of pitches from start, default 128 = all"), time_start (number, "Start time in beats, default 0"), time_span (number, "Time range in beats, default 16384 = all").
   - Handler: guardWrite, resolve track. Build args array: if any filter param provided, send [trackIndex, args.scene, pitch_start||0, pitch_span||128, time_start||0, time_span||16384]. If NO filter params provided, send just [trackIndex, args.scene] (removes all). Use `/live/clip/remove/notes` with TIMEOUTS.COMMAND. Return buildClipSnapshot.

7. **`clip_get_notes`** (read, MIDI-03):
   - Description: "Read MIDI notes from a clip. Returns structured note objects with pitch, start_time, duration, velocity, mute. Optionally filter by pitch range and time range."
   - inputSchema: track, scene (required), pitch_start (integer), pitch_span (integer), time_start (number), time_span (number).
   - Handler: resolve track. Build query args: if any filter param provided, send [trackIndex, args.scene, pitch_start||0, pitch_span||128, time_start||0, time_span||16384]. Otherwise send [trackIndex, args.scene]. Query `/live/clip/get/notes`. Response includes [track_idx, clip_idx, ...note_data]. Slice off first 2 elements: `const noteData = response.slice(2);`. Convert with flatArrayToNotes(noteData). Return `{track_index: trackIndex, clip_index: args.scene, note_count: notes.length, notes}`.

8. **`clip_set_loop`** (write, MIDI-04):
   - Description: "Set clip loop properties. All time values in beats. Loop start must be less than loop end. When changing both, the order of operations is handled automatically to avoid constraint violations."
   - inputSchema: track, scene (required), loop_start (number, "Loop start in beats"), loop_end (number, "Loop end in beats"), looping (boolean, "Enable or disable looping").
   - Handler: guardWrite, resolve track. At least one of loop_start, loop_end, looping must be provided -- if none, return errorResponse. Handle loop point ordering correctly:
     1. If looping is provided, set it: `/live/clip/set/looping` with [trackIndex, args.scene, args.looping ? 1 : 0].
     2. If both loop_start and loop_end provided: query current values first. If new loop_end > current loop_end (expanding), set loop_end first then loop_start. Otherwise set loop_start first then loop_end.
     3. If only loop_start: set `/live/clip/set/loop_start` with [trackIndex, args.scene, args.loop_start].
     4. If only loop_end: set `/live/clip/set/loop_end` with [trackIndex, args.scene, args.loop_end].
     Return buildClipSnapshot.

**Error handling pattern:** Wrap the entire switch body in try/catch. On error, return errorResponse(err.message). This matches scene.js pattern exactly.

**Response pattern:** All write operations return full clip snapshot (consistent with transport/track patterns from Phase 3). Read operations return focused data.
  </action>
  <verify>
Run: `node -e "import('./src/tools/clip.js').then(c => { console.log('tools:', c.tools.length); console.log('names:', c.tools.map(t=>t.name).join(', ')); console.log('handle type:', typeof c.handle); const result = c.handle('clip_launch', {}); console.log('clip_launch excluded:', result === null); console.log('OK'); })"`

Expected: tools count is 7 or 8, lists all clip tool names (clip_create, clip_delete, clip_get, clip_set_name, clip_add_notes, clip_remove_notes, clip_get_notes, clip_set_loop), handle is function, clip_launch returns null (excluded), OK.
  </verify>
  <done>clip.js exports 7-8 tool definitions and a handle function. Routing excludes clip_launch and clip_stop (handled by scene.js). Write tools check guardWrite. clip_create verifies MIDI track and empty slot. clip_add_notes validates notes and chunks large batches. clip_set_loop handles loop point ordering. clip_get_notes converts flat OSC arrays to structured JSON. All write operations return clip snapshots.</done>
</task>

<task type="auto">
  <name>Task 3: Wire clip module into registry</name>
  <files>src/tools/registry.js</files>
  <action>
Modify `src/tools/registry.js`:

1. Add import at top (after the scene import): `import * as clip from './clip.js';`
2. Add `clip` to the modules array: `const modules = [health, transport, track, mixer, scene, clip];`

IMPORTANT: clip module MUST be AFTER scene in the modules array. The registry dispatches to the first module that returns non-null. Since scene.js handles `clip_launch` and `clip_stop`, and clip.js returns null for those names, the order does not strictly matter for correctness (both modules correctly exclude the other's tools). But placing clip after scene maintains the convention of adding new modules at the end.

No other changes to registry.js.
  </action>
  <verify>
Run: `node -e "import('./src/tools/registry.js').then(r => { const tools = r.getToolDefinitions(); const clipTools = tools.filter(t => t.name.startsWith('clip_')); console.log('total tools:', tools.length); console.log('clip tools:', clipTools.map(t=>t.name).join(', ')); console.log('OK'); })"`

Expected: Total tool count increases by 7-8 from Phase 3 total. Clip tools listed include clip_create, clip_delete, clip_get, clip_set_name, clip_add_notes, clip_remove_notes, clip_get_notes, clip_set_loop. No duplicate tool warnings. OK.
  </verify>
  <done>Registry imports clip module and includes it in the modules array. All clip tools appear in getToolDefinitions(). No duplicate tool name warnings. handleToolCall correctly dispatches clip_launch/clip_stop to scene.js and clip_create/clip_delete/etc to clip.js.</done>
</task>

</tasks>

<verification>
- `node -e "import('./src/tools/registry.js').then(r => { const tools = r.getToolDefinitions(); console.log('Total tools:', tools.length); console.log('No duplicates:', new Set(tools.map(t=>t.name)).size === tools.length); console.log('OK'); })"` -- no import errors, no duplicate warnings
- `node -e "import('./src/tools/helpers.js').then(h => { const flat = h.notesToFlatArray([{pitch:60,start_time:0,duration:1,velocity:100,mute:false},{pitch:64,start_time:1,duration:1,velocity:80}]); console.log('2 notes flat:', flat.length, '=== 10'); const back = h.flatArrayToNotes(flat); console.log('round-trip:', back.length, 'notes'); console.log('OK'); })"` -- note serialization round-trips correctly
- `node -e "import('./src/tools/helpers.js').then(h => { try { h.validateNotes([{pitch:200,start_time:0,duration:1}]); } catch(e) { console.log('caught:', e.message.includes('pitch')); } console.log('OK'); })"` -- validation catches invalid pitch
- All 7-8 clip tools registered without duplicate warnings
- clip_launch and clip_stop still handled by scene.js (not clip.js)
- helpers.js existing functions unchanged (volume, pan, track resolution, snapshots all still work)
</verification>

<success_criteria>
- MIDI-01: clip_create creates MIDI clips (with MIDI track + empty slot validation), clip_delete removes them, clip_set_name names them
- MIDI-02: clip_add_notes adds notes with validation and chunking, clip_remove_notes removes by filter range
- MIDI-03: clip_get_notes reads notes as structured JSON objects, clip_get returns clip properties with note count
- MIDI-04: clip_set_loop controls loop_start, loop_end, and looping with correct ordering to avoid constraint violations
- All write tools gated by guardWrite (read-only mode)
- Note serialization correctly converts between structured JSON and flat 5-value OSC arrays
- Clip responses correctly handle the [track_index, clip_index, ...value] prefix offset
- No regressions: existing tools (transport, track, mixer, scene, clip_launch, clip_stop) still work
</success_criteria>

<output>
After completion, create `.planning/phases/04-midi-clip-editing/04-01-SUMMARY.md`
</output>
