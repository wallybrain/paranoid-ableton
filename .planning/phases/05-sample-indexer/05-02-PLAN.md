---
phase: 05-sample-indexer
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/tools/sample.js
  - src/tools/registry.js
autonomous: true

must_haves:
  truths:
    - "Claude can trigger a sample scan by calling sample_scan with directory paths"
    - "Claude can search samples by instrument type, key, BPM range, text query, or character description"
    - "Claude can get index statistics showing sample counts by type and format"
    - "Claude can request a sample load and receives file path with usage instructions"
    - "Sample tools appear in the MCP server tool listing"
  artifacts:
    - path: "src/tools/sample.js"
      provides: "4 MCP tool definitions and handlers for sample operations"
      exports: ["tools", "handle"]
    - path: "src/tools/registry.js"
      provides: "Sample module registered in modules array"
      contains: "import * as sample"
  key_links:
    - from: "src/tools/sample.js"
      to: "src/sample-index/scanner.js"
      via: "import scanLibrary, getScanStatus"
      pattern: "import.*scanLibrary.*scanner"
    - from: "src/tools/sample.js"
      to: "src/sample-index/index-store.js"
      via: "import search, getStats, getEntryByPath"
      pattern: "import.*search.*index-store"
    - from: "src/tools/registry.js"
      to: "src/tools/sample.js"
      via: "import * as sample"
      pattern: "import \\* as sample from './sample.js'"
---

<objective>
Create the 4 MCP tools for sample operations and wire them into the registry.

Purpose: This connects the sample indexer engine (Plan 01) to the MCP server so Claude can scan, search, and load samples through tool calls. Follows the established domain module pattern (tools[] + handle()).

Output: src/tools/sample.js with 4 tools, registry.js updated with sample module.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sample-indexer/05-RESEARCH.md
@.planning/phases/05-sample-indexer/05-01-SUMMARY.md
@src/tools/registry.js
@src/tools/clip.js
@src/tools/shared.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sample domain module with 4 MCP tools</name>
  <files>src/tools/sample.js</files>
  <action>
Create `src/tools/sample.js` following the exact domain module pattern from clip.js and other modules: export `tools` array and `handle(name, args)` function.

**Tool 1: sample_scan**
- Description: "Scan sample directories and build/update the metadata index. Extracts duration, format, BPM, key, instrument type, and character tags from file metadata and filenames. First scan builds the full index; subsequent scans skip unchanged files (incremental). Use force=true to rescan everything."
- Input schema:
  - `directories` (required, array of strings): Absolute paths to scan. Example: ["/home/user/Music/Samples", "/home/user/Music/Ableton/User Library/Samples"]
  - `force` (optional, boolean, default false): Force full rescan ignoring cache
- Handler: Call `scanLibrary(args.directories, { force: args.force || false })`. Return the result object directly.

**Tool 2: sample_search**
- Description: "Search the sample index by instrument type, musical key, BPM range, text query, character/vibe, format, or duration. All filters are optional and combined with AND logic. Returns up to 50 results by default."
- Input schema:
  - `instrument_type` (optional, string, enum: kick, snare, hihat, cymbal, perc, bass, synth, keys, guitar, vocal, fx, loop): Filter by instrument classification
  - `key` (optional, string): Musical key, e.g. "Cmin", "F#maj", "Am"
  - `bpm_min` (optional, number): Minimum BPM (inclusive)
  - `bpm_max` (optional, number): Maximum BPM (inclusive)
  - `text` (optional, string): Substring search in filename and path
  - `character` (optional, string): Vibe/character tag, e.g. "punchy", "dark", "warm"
  - `format` (optional, string): File format, e.g. "wav", "aiff", "flac"
  - `min_duration_ms` (optional, number): Minimum duration in milliseconds
  - `max_duration_ms` (optional, number): Maximum duration in milliseconds
  - `limit` (optional, integer, default 50): Max results to return
- Handler: Call `search(args)` from index-store. If index is empty (total 0 from getStats), return a hint message: "No samples indexed yet. Run sample_scan first." Otherwise return `{ result_count, results }` where results include all entry fields.

**Tool 3: sample_get_stats**
- Description: "Get statistics about the current sample index: total count, breakdown by instrument type, format, and scan root directory."
- Input schema: No required properties (empty object).
- Handler: Call `getStats()` from index-store. Also include `getScanStatus()` to show if a scan is currently running.

**Tool 4: sample_load**
- Description: "Get the file path for a sample to load into Ableton. Currently returns the absolute path for manual drag-and-drop into a track. Future versions will load directly via AbletonOSC browser API when available."
- Input schema:
  - `path` (required, string): Absolute path to the sample file (from search results)
  - `track` (optional, description: "Target track index or name -- reserved for future use when direct loading is supported")
- Handler: Call `getEntryByPath(args.path)` from index-store. If not found, return error "SAMPLE_NOT_FOUND: Sample not in index. Run sample_search to find available samples." If found, return `{ path: entry.path, filename: entry.filename, duration_ms: entry.duration_ms, instrument_type: entry.instrument_type, instructions: "Drag this file into the desired Ableton track: <path>" }`.

**Pattern notes:**
- Use `jsonResponse(data)` and `errorResponse(message)` local helper functions (same pattern as clip.js).
- The `handle` function should check `if (!name.startsWith('sample_')) return null;` for dispatch.
- No OSC or ensureConnected needed -- sample tools are filesystem-only (except sample_load which is best-effort).
- Import from '../sample-index/scanner.js' and '../sample-index/index-store.js'.
- Call `loadIndex()` at the start of search/stats/load handlers to ensure index is loaded into memory. loadIndex is idempotent (if already loaded, it's a no-op in memory; but if the JSON file has been updated by a scan, it reloads).

Actually, refine: `loadIndex` should be called once at module load time would be wrong (blocks startup). Instead, the scanner already calls loadIndex before scanning. For search/stats/load, call loadIndex at the start of each handler to ensure the latest persisted index is in memory. This is a cheap operation (read JSON file once, subsequent calls can check a loaded flag).
  </action>
  <verify>
`node -e "import { tools, handle } from './src/tools/sample.js'; console.log('tools:', tools.map(t => t.name)); console.log('count:', tools.length);"` outputs 4 tool names: sample_scan, sample_search, sample_get_stats, sample_load.
  </verify>
  <done>sample.js exports 4 tools and handle function following the established domain module pattern. All tools have proper inputSchema with descriptions.</done>
</task>

<task type="auto">
  <name>Task 2: Wire sample module into registry</name>
  <files>src/tools/registry.js</files>
  <action>
Update `src/tools/registry.js`:

1. Add import at the top: `import * as sample from './sample.js';`
2. Add `sample` to the `modules` array: `const modules = [health, transport, track, mixer, scene, clip, sample];`

No other changes needed. The existing module dispatch loop in `handleToolCall` will automatically route sample_* calls to the sample module's handle function.

Verify no duplicate tool names after adding the 4 new sample tools.
  </action>
  <verify>
`node -e "import { getToolDefinitions } from './src/tools/registry.js'; const tools = getToolDefinitions(); const sampleTools = tools.filter(t => t.name.startsWith('sample_')); console.log('sample tools:', sampleTools.length); console.log('total tools:', tools.length);"` shows 4 sample tools and total ~48 tools (44 prior + 4 new). No duplicate warnings on stderr.
  </verify>
  <done>Sample module is registered in the MCP server. All 4 sample tools appear in tool listings and route correctly through the registry dispatcher.</done>
</task>

</tasks>

<verification>
1. `node -e "import { getToolDefinitions } from './src/tools/registry.js'; console.log(getToolDefinitions().filter(t => t.name.startsWith('sample_')).map(t => t.name));"` lists all 4 sample tools
2. `node -e "import { handle } from './src/tools/sample.js'; handle('sample_get_stats', {}).then(r => console.log(r.content[0].text));"` returns stats (with total_samples: 0 if no scan done)
3. `node -e "import { handle } from './src/tools/sample.js'; handle('sample_load', { path: '/nonexistent' }).then(r => console.log(r.content[0].text));"` returns SAMPLE_NOT_FOUND error
4. No warnings about duplicate tool names during registry load
</verification>

<success_criteria>
- src/tools/sample.js exports tools[] with 4 tools and handle() function
- src/tools/registry.js imports and includes sample module
- sample_scan accepts directories array and returns scan results
- sample_search accepts all filter fields and returns matching entries
- sample_get_stats returns index statistics
- sample_load returns file path with instructions (or error if not found)
- All tools are accessible through the MCP server tool listing
</success_criteria>

<output>
After completion, create `.planning/phases/05-sample-indexer/05-02-SUMMARY.md`
</output>
