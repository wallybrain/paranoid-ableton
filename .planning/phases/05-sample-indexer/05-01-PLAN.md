---
phase: 05-sample-indexer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/sample-index/scanner.js
  - src/sample-index/classifier.js
  - src/sample-index/index-store.js
autonomous: true

must_haves:
  truths:
    - "Scanner can recursively find audio files in a directory tree"
    - "Classifier extracts instrument type, BPM, and key from filenames and paths"
    - "Metadata extraction pulls duration, sample rate, and embedded tags from audio files"
    - "Index store persists entries to JSON and loads them back"
    - "Search filters by instrument_type, key, bpm range, text, and format in under 100ms for 10k entries"
    - "Concurrent scan attempts are rejected with a clear message"
    - "Incremental scan skips unchanged files based on mtime"
  artifacts:
    - path: "src/sample-index/scanner.js"
      provides: "File walking, metadata extraction, scan orchestration"
      exports: ["scanLibrary", "getScanStatus"]
    - path: "src/sample-index/classifier.js"
      provides: "Filename/path heuristic classification for instrument type, BPM, key, character tags"
      exports: ["classifyFromPath", "INSTRUMENT_KEYWORDS", "CHARACTER_KEYWORDS"]
    - path: "src/sample-index/index-store.js"
      provides: "In-memory index with JSON persistence, search, stats"
      exports: ["loadIndex", "saveIndex", "addEntry", "search", "getStats", "getEntryByPath", "clearIndex"]
  key_links:
    - from: "src/sample-index/scanner.js"
      to: "src/sample-index/classifier.js"
      via: "import classifyFromPath"
      pattern: "import.*classifyFromPath.*classifier"
    - from: "src/sample-index/scanner.js"
      to: "src/sample-index/index-store.js"
      via: "import addEntry, loadIndex, saveIndex"
      pattern: "import.*addEntry.*index-store"
    - from: "src/sample-index/scanner.js"
      to: "music-metadata"
      via: "import parseFile"
      pattern: "import.*parseFile.*music-metadata"
---

<objective>
Build the sample indexer engine: directory scanner, filename/path classifier, and in-memory index store with JSON persistence.

Purpose: This is the standalone data pipeline for Phase 5. It has no MCP or OSC dependency -- pure Node.js file system and metadata extraction. The three modules (scanner, classifier, index-store) form the foundation that MCP tools will call in Plan 02.

Output: Three working modules in src/sample-index/ plus music-metadata dependency installed.
</objective>

<execution_context>
@/home/lwb3/.claude/get-shit-done/workflows/execute-plan.md
@/home/lwb3/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sample-indexer/05-RESEARCH.md
@src/tools/shared.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install music-metadata and create classifier module</name>
  <files>package.json, src/sample-index/classifier.js</files>
  <action>
Run `npm install music-metadata` in the project root.

Create `src/sample-index/classifier.js` that exports:

1. `INSTRUMENT_KEYWORDS` -- object mapping instrument type strings to arrays of keyword aliases. Types: kick, snare, hihat, cymbal, perc, bass, synth, keys, guitar, vocal, fx, loop. Use the keyword lists from the research (e.g., kick: ['kick', 'kck', 'bd', 'bassdrum', 'bass_drum', 'bass-drum']).

2. `CHARACTER_KEYWORDS` -- array of descriptive/vibe words to extract as tags: warm, dark, bright, punchy, soft, hard, dry, wet, analog, digital, lo-fi, lofi, vintage, modern, aggressive, mellow, crisp, fat, thin, heavy, light, deep, raw, clean, dirty, distorted, filtered, processed, organic, acoustic, electric, ambient, atmospheric.

3. `classifyFromPath(filePath)` -- function that takes a full file path and returns `{ instrument_type, bpm, key, character_tags }`.
   - **instrument_type**: Check both filename and folder path against INSTRUMENT_KEYWORDS. Filename match takes priority. Return the first match or null.
   - **bpm**: Match patterns in the filename: `(\d{2,3})\s*bpm`, `bpm\s*(\d{2,3})`, `[_\-](\d{2,3})[_\-]` (only if value is 40-300). Return integer or null.
   - **key**: Match pattern `\b([A-G][#b]?)\s*(min(?:or)?|maj(?:or)?|m(?!\w))\b` in filename. Normalize to format like "Cmin", "F#maj". Return string or null.
   - **character_tags**: Scan filename (not full path) for CHARACTER_KEYWORDS. Split filename on common delimiters (_, -, space, .) and check each token. Return array of matched strings (may be empty).

The function should lowercase the path for matching but return properly-cased values. Use `path.basename()` to isolate filename, `path.dirname()` for folder path analysis.
  </action>
  <verify>
`node -e "import { classifyFromPath } from './src/sample-index/classifier.js'; const r = classifyFromPath('/samples/Drums/Kicks/kick_120bpm_Cmin_punchy.wav'); console.log(JSON.stringify(r));"` outputs `{"instrument_type":"kick","bpm":120,"key":"Cmin","character_tags":["punchy"]}`
  </verify>
  <done>classifier.js exports classifyFromPath that correctly identifies instrument type, BPM, key, and character tags from filenames and paths. music-metadata is in package.json dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Create index store with search and persistence</name>
  <files>src/sample-index/index-store.js</files>
  <action>
Create `src/sample-index/index-store.js` with an in-memory index backed by JSON file persistence.

**Index entry schema** (each sample produces one entry):
```
{
  path: string,            // absolute path
  relative_path: string,   // path relative to scan root
  filename: string,        // basename
  extension: string,       // e.g. ".wav" (lowercase, with dot)
  duration_ms: number|null,
  sample_rate: number|null,
  bit_depth: number|null,
  channels: number|null,
  codec: string|null,
  bpm: number|null,
  key: string|null,
  instrument_type: string|null,
  character_tags: string[],
  file_size: number,
  mtime_ms: number,
  scan_root: string        // which directory this was scanned from
}
```

**Exports:**

1. `loadIndex(indexPath)` -- Read JSON file at indexPath into memory. If file missing/corrupt, start empty. Build a Map keyed by `entry.path` for O(1) lookups.

2. `saveIndex(indexPath)` -- Write current index array to JSON file. Create parent directory with `mkdir({ recursive: true })` if needed.

3. `addEntry(entry)` -- Add or update (upsert by path) an entry in the in-memory index.

4. `removeEntry(path)` -- Remove entry by absolute path.

5. `getEntryByPath(path)` -- O(1) lookup by absolute path. Returns entry or null.

6. `search(query)` -- Filter the in-memory index array. Query fields (all optional):
   - `instrument_type` (string) -- exact match
   - `key` (string) -- exact match
   - `bpm_min` (number) -- entries with bpm >= this (skip entries with null bpm)
   - `bpm_max` (number) -- entries with bpm <= this
   - `text` (string) -- case-insensitive substring match on filename OR path
   - `format` (string) -- match extension (normalize: if user passes "wav", match ".wav")
   - `character` (string) -- match any character_tag (case-insensitive)
   - `min_duration_ms` (number) -- entries with duration >= this
   - `max_duration_ms` (number) -- entries with duration <= this
   - `limit` (number, default 50) -- max results

7. `getStats()` -- Return `{ total_samples, by_instrument_type: { kick: N, snare: N, ... }, by_format: { ".wav": N, ... }, by_scan_root: { "/path": N, ... } }`.

8. `clearIndex()` -- Empty the in-memory index (for testing).

**INDEX_PATH default:** `path.join(process.cwd(), 'data', 'sample-index.json')` but all functions accept an optional path parameter to override.

Keep it simple: the index is a plain array, the path map is rebuilt on load. No classes needed -- module-level state with exported functions.
  </action>
  <verify>
`node -e "
import { addEntry, search, getStats, clearIndex } from './src/sample-index/index-store.js';
clearIndex();
addEntry({ path: '/a/kick.wav', relative_path: 'kick.wav', filename: 'kick.wav', extension: '.wav', duration_ms: 500, sample_rate: 44100, bit_depth: 16, channels: 1, codec: 'wav', bpm: 120, key: null, instrument_type: 'kick', character_tags: ['punchy'], file_size: 44100, mtime_ms: 1000, scan_root: '/a' });
addEntry({ path: '/a/snare.wav', relative_path: 'snare.wav', filename: 'snare.wav', extension: '.wav', duration_ms: 300, sample_rate: 44100, bit_depth: 16, channels: 1, codec: 'wav', bpm: null, key: null, instrument_type: 'snare', character_tags: [], file_size: 22050, mtime_ms: 1000, scan_root: '/a' });
console.log('search kick:', search({ instrument_type: 'kick' }).length);
console.log('search bpm:', search({ bpm_min: 100, bpm_max: 130 }).length);
console.log('stats:', JSON.stringify(getStats()));
"` outputs search kick: 1, search bpm: 1, stats showing total_samples: 2 with correct breakdowns.
  </verify>
  <done>index-store.js provides in-memory index with upsert, search by all required fields, stats, and JSON persistence. Search is array filter -- trivially fast for 10k entries.</done>
</task>

<task type="auto">
  <name>Task 3: Create scanner module with async metadata extraction</name>
  <files>src/sample-index/scanner.js</files>
  <action>
Create `src/sample-index/scanner.js` that orchestrates directory scanning with metadata extraction.

**Constants:**
- `AUDIO_EXTENSIONS` = Set of ['.wav', '.aiff', '.aif', '.flac', '.mp3', '.ogg', '.m4a']
- `CONCURRENCY_LIMIT` = 10 (max simultaneous parseFile calls)
- `DEFAULT_INDEX_PATH` = `path.join(process.cwd(), 'data', 'sample-index.json')`

**Module state:**
- `scanInProgress` (boolean) -- guard against concurrent scans

**Exports:**

1. `scanLibrary(directories, options)` -- Main scan function.
   - `directories`: array of absolute directory paths
   - `options.force`: boolean (default false) -- if true, rescan all files ignoring mtime cache
   - `options.indexPath`: string -- override index file location

   Logic:
   a. If `scanInProgress`, return `{ status: 'already_scanning', message: 'A scan is already in progress' }`.
   b. Set `scanInProgress = true` in try/finally block.
   c. Call `loadIndex(indexPath)` to load existing entries.
   d. For each directory: use `fs.readdir(dir, { recursive: true })` to get all entries, filter by AUDIO_EXTENSIONS (case-insensitive extname check).
   e. For each audio file, check if already indexed with same mtime (via `getEntryByPath`). Skip if mtime matches and `force` is false. Track `skipped` count.
   f. For new/changed files, extract metadata using `parseFile` from music-metadata (with `{ duration: true, skipCovers: true }`). Use a concurrency limiter: process files in batches of CONCURRENCY_LIMIT using Promise.all.
   g. Merge music-metadata results with `classifyFromPath` results. Embedded metadata (bpm, key) takes priority over filename heuristics when present (non-null).
   h. Build entry object and call `addEntry`.
   i. After all directories processed, call `saveIndex(indexPath)`.
   j. Return `{ status: 'complete', scanned: N, indexed: N, skipped: N, errors: N, total: totalEntries }`.

   Error handling: If parseFile throws for a file (corrupt, unsupported), increment `errors` count and continue. Never abort scan for individual file failures. Log to stderr: `console.error('Scan error: ${filePath}: ${err.message}')`.

2. `getScanStatus()` -- Return `{ scanning: scanInProgress }`.

**Concurrency limiter pattern** (no external dependency):
```javascript
async function processInBatches(items, batchSize, fn) {
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    await Promise.all(batch.map(fn));
  }
}
```

Use `fs.stat` to get file size and mtime for each file. Compute `relative_path` as the file's path relative to its scan root directory using `path.relative(scanRoot, filePath)`.
  </action>
  <verify>
Create a temp test: `node -e "import { getScanStatus } from './src/sample-index/scanner.js'; console.log(JSON.stringify(getScanStatus()));"` outputs `{"scanning":false}`. Module imports without errors. (Full scan test requires audio files, verified via MCP tools in Plan 02.)
  </verify>
  <done>scanner.js can walk directories, extract metadata via music-metadata, classify via classifier.js, persist via index-store.js. Concurrent scans are guarded. Incremental scanning skips unchanged files.</done>
</task>

</tasks>

<verification>
1. `npm ls music-metadata` shows music-metadata installed
2. All three modules import without errors: `node -e "import './src/sample-index/scanner.js'; import './src/sample-index/classifier.js'; import './src/sample-index/index-store.js'; console.log('OK')"`
3. Classifier correctly parses test filenames with BPM, key, instrument type, and character tags
4. Index store search/stats work with in-memory entries
5. Scanner module loads and reports scan status
</verification>

<success_criteria>
- music-metadata dependency installed in package.json
- src/sample-index/classifier.js correctly classifies instrument type, BPM, key, and character tags from paths
- src/sample-index/index-store.js provides in-memory search, JSON persistence, and stats
- src/sample-index/scanner.js orchestrates scanning with concurrency control and incremental mtime checking
- All three modules are importable and self-consistent
</success_criteria>

<output>
After completion, create `.planning/phases/05-sample-indexer/05-01-SUMMARY.md`
</output>
