---
phase: 07-session-awareness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/helpers.js
  - src/tools/session.js
  - src/tools/registry.js
autonomous: true

must_haves:
  truths:
    - "session_snapshot tool returns complete session state including transport, all tracks with clips, devices, routing, and grouping"
    - "session_stats tool returns aggregate project statistics (track counts by type, clip counts, device chain summary)"
    - "Empty clip slots are distinguished from populated clips using bulk clip names query"
    - "Device chain summaries use bulk queries (devices/name, devices/type) not per-device individual queries"
  artifacts:
    - path: "src/tools/session.js"
      provides: "Session domain module with tools[] and handle()"
      exports: ["tools", "handle"]
    - path: "src/tools/helpers.js"
      provides: "buildSessionSnapshot, buildTrackDetailSnapshot, buildSessionStats helper functions"
      contains: "buildSessionSnapshot"
    - path: "src/tools/registry.js"
      provides: "Session module registered in modules array"
      contains: "import * as session"
  key_links:
    - from: "src/tools/session.js"
      to: "src/tools/helpers.js"
      via: "import buildSessionSnapshot, buildSessionStats"
      pattern: "import.*buildSessionSnapshot.*from.*helpers"
    - from: "src/tools/session.js"
      to: "src/tools/shared.js"
      via: "import ensureConnected"
      pattern: "import.*ensureConnected.*from.*shared"
    - from: "src/tools/registry.js"
      to: "src/tools/session.js"
      via: "import * as session and inclusion in modules array"
      pattern: "import \\* as session"
---

<objective>
Implement session_snapshot and session_stats MCP tools for complete Live Object Model state awareness.

Purpose: Claude needs to understand the full state of an Ableton session (tracks, clips, devices, routing, grouping) before making context-aware creative decisions. This phase aggregates all existing data sources into two comprehensive read-only tools.

Output: New session.js domain module with 2 tools, 3 new helper functions in helpers.js, and registry wiring.
</objective>

<execution_context>
@/home/lwb3/.claude/agents/gsd-planner.md
@/home/lwb3/.claude/get-shit-done/workflows/execute-plan.md
@/home/lwb3/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-session-awareness/07-RESEARCH.md
@src/tools/helpers.js
@src/tools/registry.js
@src/tools/device.js
@src/tools/shared.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session helper functions to helpers.js</name>
  <files>src/tools/helpers.js</files>
  <action>
Add three new exported async functions to the end of helpers.js (before closing, after buildDeviceSnapshot):

1. `buildTrackDetailSnapshot(client, trackIndex, numScenes)`:
   - Call existing `buildTrackSnapshot(client, trackIndex)` for base data (name, volume, pan, mute, solo, arm, type, device_count)
   - Query routing: `/live/track/get/input_routing_type` with [trackIndex] -> response is [trackId, type_name], destructure as `const inputResp = await client.query(...)` then `inputResp[1]` for the type name
   - Query routing: `/live/track/get/output_routing_type` with [trackIndex] -> same pattern, `outputResp[1]`
   - Query grouping: `/live/track/get/is_foldable` with [trackIndex] -> response [trackId, 0|1], use `resp[1]`
   - Query grouping: `/live/track/get/is_grouped` with [trackIndex] -> same pattern
   - Query clip slots: `/live/track/get/clips/name` with [trackIndex] -> response [trackId, name0, name1, ...], use `clipNamesResp.slice(1)` to get names array
   - Build clips array: iterate 0 to numScenes-1, if `clipNames[s]` exists and is not empty string `''`, push `{ scene: s, name: clipNames[s], has_clip: true }`
   - Query devices (only if base.device_count > 0): `/live/track/get/devices/name` with [trackIndex] -> `namesResp.slice(1)`, and `/live/track/get/devices/type` with [trackIndex] -> `typesResp.slice(1)`
   - Build devices array: iterate 0 to base.device_count-1, push `{ index: d, name: devNames[d], type: deviceTypeNames[devTypes[d]] || 'unknown' }`
   - Note: `deviceTypeNames` is already defined in helpers.js as `{ 1: 'audio_effect', 2: 'instrument', 4: 'midi_effect' }` -- but it's currently a `const` local to buildDeviceSnapshot. Move the `const deviceTypeNames = ...` declaration ABOVE buildDeviceSnapshot so both functions can use it. Do NOT re-declare it.
   - Return: `{ ...base, input_routing: inputType, output_routing: outputType, is_group: !!isFoldable, is_grouped: !!isGrouped, clips, devices }`

2. `buildSessionSnapshot(client)`:
   - Query `/live/song/get/num_tracks` -> destructure `[numTracks]`
   - Query `/live/song/get/num_scenes` -> destructure `[numScenes]`
   - Call `buildTransportSnapshot(client)` for transport state
   - Loop `t = 0` to `numTracks - 1`, call `buildTrackDetailSnapshot(client, t, numScenes)`, collect into tracks array
   - Return: `{ transport, track_count: numTracks, scene_count: numScenes, tracks }`

3. `buildSessionStats(client)`:
   - Call `buildTransportSnapshot(client)` for transport
   - Query `/live/song/get/num_tracks` and `/live/song/get/num_scenes`
   - Initialize counters: `midiCount = 0, audioCount = 0, groupCount = 0, totalClips = 0, totalDevices = 0`
   - Initialize `deviceSummary = {}` (object mapping device name -> count)
   - Loop `t = 0` to `numTracks - 1`:
     - Query `/live/track/get/has_midi_input` with [t] -> `[hasMidi]`
     - Query `/live/track/get/has_audio_input` with [t] -> `[hasAudio]`
     - Query `/live/track/get/is_foldable` with [t] -> response [trackId, val], use `resp[1]` for isFoldable
     - Query `/live/track/get/num_devices` with [t] -> `[numDevices]`
     - Classify: if isFoldable -> groupCount++, else if hasMidi -> midiCount++, else if hasAudio -> audioCount++
     - `totalDevices += numDevices`
     - Query `/live/track/get/clips/name` with [t] -> `clipNamesResp.slice(1)`, count non-empty names -> `totalClips += names.filter(n => n && n !== '').length`
     - If numDevices > 0: query `/live/track/get/devices/name` with [t] -> `devNamesResp.slice(1)`, for each name: `deviceSummary[name] = (deviceSummary[name] || 0) + 1`
   - Return: `{ transport, track_counts: { total: numTracks, midi: midiCount, audio: audioCount, group: groupCount }, scene_count: numScenes, total_clips: totalClips, total_devices: totalDevices, device_summary: deviceSummary }`

IMPORTANT response format notes from research:
- Per-track routing/grouping queries return [trackId, value] -- use index [1] not destructure [value] from position 0
- Bulk clip/device name queries return [trackId, name0, name1, ...] -- use slice(1)
- has_midi_input, has_audio_input, num_devices are on buildTrackSnapshot pattern returning [value] -- destructure as [value] from position 0
- BUT is_foldable in buildSessionStats is queried directly (not via buildTrackSnapshot), and it returns [trackId, val] -- use index [1]
  </action>
  <verify>
Run `node -e "import('./src/tools/helpers.js').then(m => { console.log(typeof m.buildSessionSnapshot, typeof m.buildTrackDetailSnapshot, typeof m.buildSessionStats); })"` from project root. Should print "function function function".
  </verify>
  <done>Three new async helper functions exported from helpers.js: buildSessionSnapshot, buildTrackDetailSnapshot, buildSessionStats. deviceTypeNames const moved above both buildDeviceSnapshot and buildTrackDetailSnapshot.</done>
</task>

<task type="auto">
  <name>Task 2: Create session.js domain module and wire into registry</name>
  <files>src/tools/session.js, src/tools/registry.js</files>
  <action>
**Create src/tools/session.js** following the exact domain module pattern from device.js, track.js, etc:

```javascript
import { ensureConnected } from './shared.js';
import { buildSessionSnapshot, buildSessionStats } from './helpers.js';

export const tools = [
  {
    name: 'session_snapshot',
    description: 'Get a complete session state snapshot including transport, all tracks with clips, devices, routing, and grouping. Use this to understand the full session context before making creative decisions. Does NOT include device parameters or note data (use device_get_parameters and clip_get_notes for those). Return tracks and master track are not included (AbletonOSC limitation).',
    inputSchema: {
      type: 'object',
      properties: {},
      required: []
    }
  },
  {
    name: 'session_stats',
    description: 'Get aggregate project statistics: track counts by type (midi/audio/group), total clip count, device chain summary, tempo, and time signature. Lightweight alternative to full snapshot when you only need counts and overview.',
    inputSchema: {
      type: 'object',
      properties: {},
      required: []
    }
  }
];

function jsonResponse(data) {
  return {
    content: [{ type: 'text', text: JSON.stringify(data) }]
  };
}

function errorResponse(message) {
  return {
    content: [{ type: 'text', text: 'SESSION_ERROR: ' + message }],
    isError: true
  };
}

export async function handle(name, args) {
  if (!name.startsWith('session_')) return null;

  try {
    switch (name) {
      case 'session_snapshot': {
        const client = await ensureConnected();
        const snapshot = await buildSessionSnapshot(client);
        return jsonResponse(snapshot);
      }

      case 'session_stats': {
        const client = await ensureConnected();
        const stats = await buildSessionStats(client);
        return jsonResponse(stats);
      }

      default:
        return null;
    }
  } catch (err) {
    return errorResponse(err.message);
  }
}
```

Both tools are read-only -- no guardWrite check needed.

**Update src/tools/registry.js:**
1. Add import: `import * as session from './session.js';` after the device import line
2. Add `session` to the modules array: `const modules = [health, transport, track, mixer, scene, clip, sample, device, session];`
  </action>
  <verify>
Run `node -e "import('./src/tools/registry.js').then(m => { const tools = m.getToolDefinitions(); const names = tools.map(t => t.name); console.log('session_snapshot:', names.includes('session_snapshot')); console.log('session_stats:', names.includes('session_stats')); console.log('total tools:', names.length); })"` from project root. Should show both true and a total tool count that is 2 more than before (previous was ~46 tools, now ~48).
  </verify>
  <done>session.js created with 2 tools following domain module pattern. Registry updated with session import and module inclusion. Both session_snapshot and session_stats appear in tool definitions.</done>
</task>

</tasks>

<verification>
1. `node -e "import('./src/tools/helpers.js').then(m => console.log('exports ok:', typeof m.buildSessionSnapshot === 'function' && typeof m.buildTrackDetailSnapshot === 'function' && typeof m.buildSessionStats === 'function'))"` -- prints "exports ok: true"
2. `node -e "import('./src/tools/registry.js').then(m => { const t = m.getToolDefinitions(); console.log(t.filter(x => x.name.startsWith('session_')).map(x => x.name)); })"` -- prints ['session_snapshot', 'session_stats']
3. `node -c src/tools/session.js && node -c src/tools/helpers.js && node -c src/tools/registry.js` -- all pass syntax check
</verification>

<success_criteria>
- session_snapshot and session_stats tools registered and visible in MCP tool list
- Helper functions exported and importable from helpers.js
- No duplicate tool names in registry
- All three modified files pass syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/07-session-awareness/07-01-SUMMARY.md`
</output>
