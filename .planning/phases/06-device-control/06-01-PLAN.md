---
phase: 06-device-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/helpers.js
  - src/tools/device.js
  - src/tools/registry.js
autonomous: true

must_haves:
  truths:
    - "Claude can list all devices on any track with chain order, names, types, and class names"
    - "Claude can get detailed info for a single device including parameter count"
    - "Claude can toggle a device on/off using the parameter 0 'Device On' workaround"
    - "Claude can list all parameters of a device with names, values, min, max, and quantization"
    - "Claude can get a single parameter by index or name with its value_string"
    - "Claude can set a single parameter by index or name with min/max validation"
    - "Claude can select a device in Ableton's UI"
    - "Claude can delete a device from a track"
    - "Claude can load an Ableton native instrument or effect from the browser"
  artifacts:
    - path: "src/tools/device.js"
      provides: "Device domain module with 9 tools"
      exports: ["tools", "handle"]
    - path: "src/tools/helpers.js"
      provides: "buildDeviceSnapshot and resolveParameterIndex helpers"
      contains: "buildDeviceSnapshot"
    - path: "src/tools/registry.js"
      provides: "Device module registration"
      contains: "import * as device"
  key_links:
    - from: "src/tools/device.js"
      to: "src/tools/helpers.js"
      via: "import resolveParameterIndex, buildDeviceSnapshot, resolveTrackIndex, guardWrite"
      pattern: "import.*resolveParameterIndex.*from.*helpers"
    - from: "src/tools/device.js"
      to: "src/osc-client.js"
      via: "import TIMEOUTS"
      pattern: "import.*TIMEOUTS.*from.*osc-client"
    - from: "src/tools/registry.js"
      to: "src/tools/device.js"
      via: "import * as device, added to modules array"
      pattern: "import \\* as device"
---

<objective>
Create the device domain module with 9 MCP tools for listing, controlling, and loading Ableton devices, plus shared helper functions for device snapshots and parameter resolution.

Purpose: Enables Claude to see and manipulate the device chains on Ableton tracks -- listing instruments and effects, adjusting parameters, toggling on/off, and loading new devices. This is DEV-01 through DEV-04.
Output: src/tools/device.js (9 tools), helpers.js additions (2 functions), registry.js wiring
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-device-control/06-RESEARCH.md

# Pattern references -- follow these exactly
@src/tools/clip.js
@src/tools/helpers.js
@src/tools/registry.js
@src/tools/shared.js
@src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add device helpers to helpers.js</name>
  <files>src/tools/helpers.js</files>
  <action>
Add two new exported functions to helpers.js, at the bottom of the file before the closing:

1. **resolveParameterIndex(client, trackIndex, deviceIndex, paramRef)**
   - If paramRef is a number, return it directly (like resolveTrackIndex pattern)
   - If paramRef is a string, query `/live/device/get/parameters/name` with args `[trackIndex, deviceIndex]`, TIMEOUTS.QUERY
   - Response format: `[track_id, device_id, name1, name2, ...]` -- slice(2) to get names array
   - Find exact match with `names.findIndex(n => n === paramRef)`
   - If not found, throw: `'PARAMETER_NOT_FOUND: No parameter named "' + paramRef + '" on device ' + deviceIndex`
   - If paramRef is neither number nor string, throw: `'INVALID_PARAMETER: Expected number or string, got ' + typeof paramRef`
   - Return the resolved integer index

2. **buildDeviceSnapshot(client, trackIndex, deviceIndex)**
   - Follow buildClipSnapshot pattern exactly (individual queries, destructure responses)
   - Query these OSC endpoints (all with TIMEOUTS.QUERY):
     - `/live/device/get/name` with `[trackIndex, deviceIndex]` -> `[, , name]`
     - `/live/device/get/class_name` with `[trackIndex, deviceIndex]` -> `[, , className]`
     - `/live/device/get/type` with `[trackIndex, deviceIndex]` -> `[, , type]`
     - `/live/device/get/num_parameters` with `[trackIndex, deviceIndex]` -> `[, , numParams]`
   - Map type integers to names: `{ 1: 'audio_effect', 2: 'instrument', 4: 'midi_effect' }`
   - Return object: `{ track_index: trackIndex, device_index: deviceIndex, name, class_name: className, type: typeNames[type] || 'unknown', type_id: type, parameter_count: numParams }`

Both functions need to import TIMEOUTS -- it's already imported at the top of helpers.js.
  </action>
  <verify>
Run `node -e "import('./src/tools/helpers.js').then(m => { console.log(typeof m.resolveParameterIndex, typeof m.buildDeviceSnapshot) })"` -- should print "function function".
  </verify>
  <done>helpers.js exports resolveParameterIndex and buildDeviceSnapshot. Both functions follow existing patterns (resolveTrackIndex, buildClipSnapshot) exactly.</done>
</task>

<task type="auto">
  <name>Task 2: Create device.js domain module with 9 tools and wire into registry</name>
  <files>src/tools/device.js, src/tools/registry.js</files>
  <action>
Create `src/tools/device.js` following the exact clip.js domain module pattern.

**Imports:**
```javascript
import { ensureConnected } from './shared.js';
import { resolveTrackIndex, resolveParameterIndex, buildDeviceSnapshot, guardWrite } from './helpers.js';
import { TIMEOUTS } from '../osc-client.js';
```

**Response helpers** (same as clip.js):
- `jsonResponse(data)` returns `{ content: [{ type: 'text', text: JSON.stringify(data) }] }`
- `errorResponse(message)` returns `{ content: [{ type: 'text', text: 'DEVICE_ERROR: ' + message }], isError: true }`

**Export `tools` array with 9 tool definitions:**

1. **device_list** (DEV-01, read):
   - Input: `{ track: "Track index (0-based) or name" }`, required: ['track']
   - Description: "List all devices on a track in chain order with name, type, and class."

2. **device_get** (DEV-01, read):
   - Input: `{ track, device: { type: 'integer', description: '0-based device index' } }`, required: ['track', 'device']
   - Description: "Get detailed info for a single device including name, type, class, and parameter count."

3. **device_toggle** (DEV-02, write):
   - Input: `{ track, device: integer, enabled: { type: 'boolean', description: 'true to enable, false to disable' } }`, required: ['track', 'device', 'enabled']
   - Description: "Toggle a device on/off. Uses the 'Device On' parameter (parameter 0 for most native devices). Returns error if device has no toggleable parameter."

4. **device_get_parameters** (DEV-03, read):
   - Input: `{ track, device: integer }`, required: ['track', 'device']
   - Description: "List all parameters of a device with names, current values, min/max ranges, and quantization info."

5. **device_get_parameter** (DEV-03, read):
   - Input: `{ track, device: integer, parameter: { description: 'Parameter index (0-based) or name' } }`, required: ['track', 'device', 'parameter']
   - Description: "Get a single device parameter by index or name, including its human-readable value string."

6. **device_set_parameter** (DEV-03, write):
   - Input: `{ track, device: integer, parameter: "index or name", value: { type: 'number', description: 'New value (must be within parameter min/max range)' } }`, required: ['track', 'device', 'parameter', 'value']
   - Description: "Set a device parameter value by index or name. Validates value is within min/max range."

7. **device_select** (support, write):
   - Input: `{ track, device: integer }`, required: ['track', 'device']
   - Description: "Select a device in Ableton Live's UI (opens device view)."

8. **device_delete** (support, write):
   - Input: `{ track, device: integer }`, required: ['track', 'device']
   - Description: "Delete a device from a track's device chain. WARNING: Device indices shift after deletion."

9. **device_load** (DEV-04, write):
   - Input: `{ track, device_name: { type: 'string', description: 'Ableton device name (e.g., "Wavetable", "Reverb", "EQ Eight", "Compressor"). Must match browser name.' } }`, required: ['track', 'device_name']
   - Description: "Load an Ableton instrument or effect onto a track from the browser. Requires AbletonOSC insert_device patch (PR #173). Common names: Wavetable, Operator, Drift, Simpler, Reverb, Delay, EQ Eight, Compressor, Auto Filter, Utility, Arpeggiator."

**Export `handle(name, args)` function** -- follow clip.js pattern exactly:
- If `!name.startsWith('device_')` return null
- Try/catch wrapping all cases, catch returns errorResponse
- Switch on name:

**device_list handler:**
- `const client = await ensureConnected()`
- `const trackIndex = await resolveTrackIndex(client, args.track)`
- Query `/live/track/get/num_devices` with `[trackIndex]` -> response format: `[track_id, num_devices]` -- destructure as `const [, numDevices]`
- If numDevices === 0, return `{ track_index: trackIndex, device_count: 0, devices: [] }`
- Query bulk endpoints (all with `[trackIndex]`, TIMEOUTS.QUERY):
  - `/live/track/get/devices/name` -> `namesResp`, slice(1) for names
  - `/live/track/get/devices/type` -> `typesResp`, slice(1) for types
  - `/live/track/get/devices/class_name` -> `classResp`, slice(1) for classes
- NOTE on response format: Track-level bulk queries prefix with `[track_id, ...]` so slice(1). Validate by checking that names array length equals numDevices. If mismatch, log warning but continue.
- Map to device objects: `{ index: i, name: names[i], class_name: classes[i], type: typeNames[types[i]] || 'unknown', type_id: types[i] }`
- Return: `{ track_index: trackIndex, device_count: numDevices, devices }`

**device_get handler:**
- ensureConnected, resolveTrackIndex
- `const snapshot = await buildDeviceSnapshot(client, trackIndex, args.device)`
- Return snapshot

**device_toggle handler:**
- guardWrite('device_toggle'), ensureConnected, resolveTrackIndex
- First check parameter 0 name: query `/live/device/get/parameter/name` with `[trackIndex, args.device, 0]` -> `[, , , paramName]`
- If paramName === 'Device On':
  - Set parameter 0: `/live/device/set/parameter/value` with `[trackIndex, args.device, 0, args.enabled ? 1.0 : 0.0]`, TIMEOUTS.COMMAND
  - `toggleParamIndex = 0`
- Else:
  - Search all parameter names: query `/live/device/get/parameters/name` with `[trackIndex, args.device]`
  - `const names = namesResp.slice(2)`
  - `const idx = names.findIndex(n => n === 'Device On')`
  - If idx === -1: return errorResponse('TOGGLE_UNSUPPORTED: Device has no "Device On" parameter and cannot be toggled via this API.')
  - Set found parameter: `/live/device/set/parameter/value` with `[trackIndex, args.device, idx, args.enabled ? 1.0 : 0.0]`, TIMEOUTS.COMMAND
  - `toggleParamIndex = idx`
- Build and return snapshot with `enabled` field: `{ ...snapshot, enabled: args.enabled, toggle_parameter_index: toggleParamIndex }`

**device_get_parameters handler:**
- ensureConnected, resolveTrackIndex
- Query bulk parameter endpoints (all with `[trackIndex, args.device]`, TIMEOUTS.QUERY):
  - `/live/device/get/num_parameters` -> `[, , numParams]`
  - `/live/device/get/parameters/name` -> slice(2) for names
  - `/live/device/get/parameters/value` -> slice(2) for values
  - `/live/device/get/parameters/min` -> slice(2) for mins
  - `/live/device/get/parameters/max` -> slice(2) for maxs
  - `/live/device/get/parameters/is_quantized` -> slice(2) for quantized flags
- Map to parameter objects: `{ index: i, name: names[i], value: values[i], min: mins[i], max: maxs[i], is_quantized: !!quantized[i] }`
- Return: `{ track_index: trackIndex, device_index: args.device, parameter_count: numParams, parameters }`

**device_get_parameter handler:**
- ensureConnected, resolveTrackIndex
- `const paramIndex = await resolveParameterIndex(client, trackIndex, args.device, args.parameter)`
- Query `/live/device/get/parameter/value` with `[trackIndex, args.device, paramIndex]` -> `[, , , value]`
- Query `/live/device/get/parameter/name` with `[trackIndex, args.device, paramIndex]` -> `[, , , name]`
- Query `/live/device/get/parameter/value_string` with `[trackIndex, args.device, paramIndex]` -> `[, , , valueString]`
- Return: `{ track_index: trackIndex, device_index: args.device, parameter_index: paramIndex, name, value, value_string: valueString }`

**device_set_parameter handler:**
- guardWrite('device_set_parameter'), ensureConnected, resolveTrackIndex
- `const paramIndex = await resolveParameterIndex(client, trackIndex, args.device, args.parameter)`
- Query min/max for validation:
  - `/live/device/get/parameters/min` -> slice(2), get `mins[paramIndex]`
  - `/live/device/get/parameters/max` -> slice(2), get `maxs[paramIndex]`
- Validate: if `args.value < min || args.value > max`, return errorResponse with `'VALUE_OUT_OF_RANGE: Value ' + args.value + ' outside range [' + min + ', ' + max + '] for parameter "' + paramIndex + '"'`
- Set: `/live/device/set/parameter/value` with `[trackIndex, args.device, paramIndex, args.value]`, TIMEOUTS.COMMAND
- Query updated value_string: `/live/device/get/parameter/value_string` with `[trackIndex, args.device, paramIndex]` -> `[, , , valueString]`
- Return snapshot: `{ track_index: trackIndex, device_index: args.device, parameter_index: paramIndex, value: args.value, value_string: valueString }`

**device_select handler:**
- guardWrite('device_select'), ensureConnected, resolveTrackIndex
- `/live/view/set/selected_device` with `[trackIndex, args.device]`, TIMEOUTS.COMMAND
- Build and return device snapshot

**device_delete handler:**
- guardWrite('device_delete'), ensureConnected, resolveTrackIndex
- Build snapshot BEFORE deletion (to report what was deleted)
- `/live/track/delete_device` with `[trackIndex, args.device]`, TIMEOUTS.COMMAND
- Return: `{ deleted: true, ...snapshot }`

**device_load handler:**
- guardWrite('device_load'), ensureConnected, resolveTrackIndex
- First select the target track (PR #174 fix for browser.load_item targeting wrong track):
  - `/live/view/set/selected_track` with `[trackIndex]`, TIMEOUTS.COMMAND
- Try loading device:
  - `/live/track/insert_device` with `[trackIndex, args.device_name]`, TIMEOUTS.LOAD_DEVICE
  - Response: `[deviceIndex]` (single value) or `[track_id, deviceIndex]` -- handle both formats
  - If deviceIndex === -1: return errorResponse with `'DEVICE_NOT_FOUND: No device matching "' + args.device_name + '" in Ableton browser. Check spelling -- use exact Ableton names like "Wavetable", "EQ Eight", "Compressor".'`
- Catch timeout specifically: if err.message includes 'timeout' or 'TIMEOUT', return errorResponse with `'LOAD_FAILED: Device loading timed out. Ensure AbletonOSC has the insert_device patch applied (PR #173). See README for setup instructions.'`
- Build snapshot of newly loaded device and return

**Update registry.js:**
- Add `import * as device from './device.js';` after the sample import
- Add `device` to the modules array: `const modules = [health, transport, track, mixer, scene, clip, sample, device];`
  </action>
  <verify>
1. Run `node -e "import('./src/tools/device.js').then(m => { console.log('tools:', m.tools.length, 'handle:', typeof m.handle) })"` -- should print "tools: 9 handle: function"
2. Run `node -e "import('./src/tools/registry.js').then(m => { const tools = m.getToolDefinitions(); const deviceTools = tools.filter(t => t.name.startsWith('device_')); console.log('device tools registered:', deviceTools.length, deviceTools.map(t => t.name).join(', ')) })"` -- should print all 9 device tool names
3. Run `node -c src/tools/device.js && node -c src/tools/registry.js` -- no syntax errors
  </verify>
  <done>device.js exports 9 tools covering DEV-01 (device_list, device_get), DEV-02 (device_toggle), DEV-03 (device_get_parameters, device_get_parameter, device_set_parameter), DEV-04 (device_load), plus support tools (device_select, device_delete). All tools follow established domain module patterns. Registry correctly includes device module in dispatch chain.</done>
</task>

</tasks>

<verification>
1. `node -e "import('./src/tools/registry.js').then(m => console.log('Total tools:', m.getToolDefinitions().length))"` -- should show previous count + 9
2. All 9 device tools appear in registry: device_list, device_get, device_toggle, device_get_parameters, device_get_parameter, device_set_parameter, device_select, device_delete, device_load
3. No duplicate tool names in registry (existing duplicate check in getToolDefinitions should produce no warnings)
4. `node -c src/tools/device.js` -- no syntax errors
5. `node -c src/tools/helpers.js` -- no syntax errors
</verification>

<success_criteria>
- 9 device tools registered and callable through handleToolCall
- buildDeviceSnapshot and resolveParameterIndex exported from helpers.js
- device_toggle uses parameter 0 "Device On" workaround with fallback search
- device_set_parameter validates min/max before setting
- device_load selects track first (PR #174 fix), handles missing patch gracefully
- All write tools guarded by guardWrite()
- Error codes use DEVICE_ERROR: prefix format
- All tools follow established patterns from clip.js exactly
</success_criteria>

<output>
After completion, create `.planning/phases/06-device-control/06-01-SUMMARY.md`
</output>
