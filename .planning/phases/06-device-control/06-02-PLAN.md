---
phase: 06-device-control
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - test/device.test.js
autonomous: true

must_haves:
  truths:
    - "resolveParameterIndex returns integer for numeric input"
    - "resolveParameterIndex queries OSC and resolves string name to index"
    - "resolveParameterIndex throws PARAMETER_NOT_FOUND for unknown names"
    - "device_list returns device array with correct structure"
    - "device_toggle finds and uses 'Device On' parameter"
    - "device_set_parameter rejects values outside min/max range"
    - "device_load selects track before inserting device"
    - "Write tools are blocked in read-only mode"
  artifacts:
    - path: "test/device.test.js"
      provides: "Unit tests for device helpers and tool handlers"
      min_lines: 100
  key_links:
    - from: "test/device.test.js"
      to: "src/tools/helpers.js"
      via: "import resolveParameterIndex, buildDeviceSnapshot"
      pattern: "import.*resolveParameterIndex"
    - from: "test/device.test.js"
      to: "src/tools/device.js"
      via: "import handle from device module"
      pattern: "import.*from.*device"
    - from: "test/device.test.js"
      to: "src/tools/shared.js"
      via: "setOscClient for mock injection"
      pattern: "setOscClient"
---

<objective>
Unit tests for the device domain module covering helper functions (resolveParameterIndex, buildDeviceSnapshot) and device tool handlers (list, toggle, set_parameter, load).

Purpose: Verify device module correctness without a live Ableton connection using the established mock OscClient pattern from existing tests.
Output: test/device.test.js with comprehensive test coverage
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-device-control/06-RESEARCH.md
@.planning/phases/06-device-control/06-01-SUMMARY.md

# Test pattern references
@test/health.test.js
@test/server.test.js
@test/sample-index.test.js

# Source files to test
@src/tools/device.js
@src/tools/helpers.js
@src/tools/shared.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Device helper tests (resolveParameterIndex, buildDeviceSnapshot)</name>
  <files>test/device.test.js</files>
  <action>
Create `test/device.test.js` using Node.js built-in test runner (`node:test`) following the patterns in health.test.js and server.test.js.

**Mock setup** (follow existing test pattern):
- Import `{ describe, it, beforeEach, afterEach }` from `node:test`
- Import `assert` from `node:assert/strict`
- Import `{ setOscClient }` from `../src/tools/shared.js`
- Import `{ resolveParameterIndex, buildDeviceSnapshot }` from `../src/tools/helpers.js`
- Import `{ handle }` from `../src/tools/device.js`

Create a mock OscClient factory that maps OSC addresses to response values:

```javascript
function createMockClient(responseMap) {
  return {
    query: async (address, args) => {
      const key = address + (args ? ':' + args.join(',') : '');
      if (responseMap[key]) return responseMap[key];
      // Try address-only match (no args)
      if (responseMap[address]) return responseMap[address];
      throw new Error('TIMEOUT: No mock response for ' + key);
    }
  };
}
```

**Test suite 1: resolveParameterIndex**

- `describe('resolveParameterIndex', () => { ... })`

Tests:
1. "returns integer directly for numeric input" -- `resolveParameterIndex(client, 0, 0, 5)` returns 5 (no OSC query needed)
2. "resolves string name to parameter index" -- mock `/live/device/get/parameters/name` with `[0, 0]` returning `[0, 0, 'Device On', 'Filter Freq', 'Resonance']`, then `resolveParameterIndex(client, 0, 0, 'Resonance')` returns 2
3. "throws PARAMETER_NOT_FOUND for unknown name" -- same mock, `resolveParameterIndex(client, 0, 0, 'NonExistent')` rejects with error matching /PARAMETER_NOT_FOUND/
4. "throws INVALID_PARAMETER for non-string non-number" -- `resolveParameterIndex(client, 0, 0, true)` rejects with error matching /INVALID_PARAMETER/

**Test suite 2: buildDeviceSnapshot**

- `describe('buildDeviceSnapshot', () => { ... })`

Mock responses for track 0, device 0:
- `/live/device/get/name:0,0` -> `[0, 0, 'Wavetable']`
- `/live/device/get/class_name:0,0` -> `[0, 0, 'InstrumentGroupDevice']`
- `/live/device/get/type:0,0` -> `[0, 0, 2]`
- `/live/device/get/num_parameters:0,0` -> `[0, 0, 64]`

Tests:
1. "returns correct snapshot structure" -- call buildDeviceSnapshot(client, 0, 0), assert result has all expected fields: track_index=0, device_index=0, name='Wavetable', class_name='InstrumentGroupDevice', type='instrument', type_id=2, parameter_count=64
2. "maps type 1 to audio_effect" -- mock type response as `[0, 0, 1]`, assert type='audio_effect'
3. "maps unknown type to 'unknown'" -- mock type response as `[0, 0, 99]`, assert type='unknown'

**Test suite 3: device tool handlers**

- `describe('device handle()', () => { ... })`

Use `beforeEach` to set up mock client via `setOscClient(mockClient)` and `afterEach` to `setOscClient(null)`.

Tests:
1. "device_list returns devices in chain order" -- mock:
   - `/live/track/get/num_devices:0` -> `[0, 2]`
   - `/live/track/get/devices/name:0` -> `[0, 'Reverb', 'Compressor']`
   - `/live/track/get/devices/type:0` -> `[0, 1, 1]`
   - `/live/track/get/devices/class_name:0` -> `[0, 'Reverb', 'Compressor']`
   - Also mock resolveTrackIndex needs: `/live/song/get/num_tracks` -> `[4]` (not needed if track=0 as integer)
   Call `handle('device_list', { track: 0 })`, parse JSON response, assert device_count=2 and devices array has correct names and types.

2. "device_list returns empty for track with no devices" -- mock num_devices=0. Assert device_count=0, devices=[].

3. "device_toggle uses parameter 0 when it is 'Device On'" -- mock:
   - `/live/device/get/parameter/name:0,0,0` -> `[0, 0, 0, 'Device On']`
   - `/live/device/set/parameter/value:0,0,0,0` -> `[]` (set to disabled)
   - Plus buildDeviceSnapshot mocks
   Call `handle('device_toggle', { track: 0, device: 0, enabled: false })`, assert response includes `enabled: false`.

4. "device_toggle searches all params when param 0 is not 'Device On'" -- mock:
   - `/live/device/get/parameter/name:0,0,0` -> `[0, 0, 0, 'Some Other Param']`
   - `/live/device/get/parameters/name:0,0` -> `[0, 0, 'Some Other Param', 'Device On', 'Filter']`
   - `/live/device/set/parameter/value:0,0,1,1` -> `[]` (set index 1 to enabled)
   - Plus buildDeviceSnapshot mocks
   Call `handle('device_toggle', { track: 0, device: 0, enabled: true })`, assert toggle_parameter_index=1.

5. "device_set_parameter rejects value outside range" -- mock:
   - resolveParameterIndex for 'Filter Freq' resolves to index 2
   - `/live/device/get/parameters/min:0,0` -> `[0, 0, 0.0, 0.0, 20.0]`
   - `/live/device/get/parameters/max:0,0` -> `[0, 0, 1.0, 1.0, 20000.0]`
   Call `handle('device_set_parameter', { track: 0, device: 0, parameter: 2, value: 99999 })`, assert isError=true and message matches /VALUE_OUT_OF_RANGE/.

6. "device_load selects track before inserting" -- mock:
   - `/live/view/set/selected_track:0` -> `[]`
   - `/live/track/insert_device:0,Reverb` -> `[1]` (new device at index 1)
   - Plus buildDeviceSnapshot mocks for the newly loaded device
   Call `handle('device_load', { track: 0, device_name: 'Reverb' })`, assert no error and response contains device snapshot.

7. "returns null for non-device tool names" -- `handle('clip_create', {})` returns null.

8. "write tools blocked in read-only mode" -- import `setReadOnly` from helpers.js, call `setReadOnly(true)`, call `handle('device_toggle', { track: 0, device: 0, enabled: true })`, assert response includes 'READ_ONLY'. Reset with `setReadOnly(false)` in afterEach.

Note: The mock client key format needs to match exactly how query() is called. Adjust the createMockClient to handle the actual call patterns from the source code. Use numeric args joined with commas. If the mock approach from health.test.js or server.test.js differs, follow THAT approach instead.
  </action>
  <verify>
Run `node --test test/device.test.js` -- all tests pass with 0 failures.
  </verify>
  <done>All device module tests pass: resolveParameterIndex (4 tests), buildDeviceSnapshot (3 tests), device handlers (8 tests). Tests verify parameter resolution, snapshot building, toggle workaround, min/max validation, load track selection, read-only gating, and null return for non-device tools.</done>
</task>

<task type="auto">
  <name>Task 2: Run full test suite to verify no regressions</name>
  <files></files>
  <action>
Run the entire test suite to ensure the new device module and tests don't break existing tests:

```bash
node --test test/*.test.js
```

If any existing test fails, investigate and fix. The device module should not affect health, server, osc-client, or sample-index tests since it only adds new files and appends to existing ones (helpers.js, registry.js).

Common issues to watch for:
- Import errors if device.js has a syntax issue (registry.js imports it, which server.test.js may load)
- Duplicate tool name warnings in registry (check no existing tool uses a device_ prefix)
  </action>
  <verify>
`node --test test/*.test.js` -- all tests pass across all test files (health, osc-client, server, sample-index, device).
  </verify>
  <done>Full test suite passes with zero regressions. Device module integrates cleanly with existing codebase.</done>
</task>

</tasks>

<verification>
1. `node --test test/device.test.js` -- all device tests pass
2. `node --test test/*.test.js` -- full suite passes, no regressions
3. Test coverage includes: parameter resolution (numeric + string + error), snapshot building, device listing, toggle workaround (param 0 + fallback search), parameter validation (out of range), device loading (track selection + insert), read-only gating, null return for non-device tools
</verification>

<success_criteria>
- test/device.test.js exists with 15+ test cases
- All tests pass with `node --test`
- No regressions in existing test files
- Mock OscClient pattern consistent with existing tests
- Tests verify the critical behaviors: toggle workaround, parameter validation, load sequence
</success_criteria>

<output>
After completion, create `.planning/phases/06-device-control/06-02-SUMMARY.md`
</output>
