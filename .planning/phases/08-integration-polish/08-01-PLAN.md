---
phase: 08-integration-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/logger.js
  - src/tools/shared.js
  - src/osc-client.js
autonomous: true

must_haves:
  truths:
    - "First tool call per session runs an automatic health check against Ableton before proceeding"
    - "Concurrent first-calls share one health check (no race condition / double-check)"
    - "Connection loss mid-session triggers exponential backoff reconnection (500ms, 1s, 2s, cap 5s, 3 retries)"
    - "Reconnection failure provides clear troubleshooting guidance (Ableton running, AbletonOSC loaded, port conflicts)"
    - "All server logging is structured JSON on stderr (never stdout)"
    - "LOG_LEVEL env var controls log verbosity (error, warn, info, debug)"
  artifacts:
    - path: "src/logger.js"
      provides: "Structured JSON logging to stderr"
      exports: ["log"]
    - path: "src/tools/shared.js"
      provides: "Auto health check with promise lock, reconnection orchestration, resetConnectionState"
      exports: ["ensureConnected", "getOscClient", "resetClient", "setOscClient", "resetConnectionState"]
    - path: "src/osc-client.js"
      provides: "reconnect() method on OscClient class"
      contains: "async reconnect"
  key_links:
    - from: "src/tools/shared.js"
      to: "src/osc-client.js"
      via: "ensureConnected calls client.healthCheck() on first call, client.reconnect() on failure"
      pattern: "healthCheck|reconnect"
    - from: "src/tools/shared.js"
      to: "src/logger.js"
      via: "import log for connection state changes"
      pattern: "import.*log.*from.*logger"
    - from: "src/osc-client.js"
      to: "src/logger.js"
      via: "import log for reconnection attempts and errors"
      pattern: "import.*log.*from.*logger"
---

<objective>
Add structured logging, auto health check on first tool call, and exponential backoff reconnection to the MCP server.

Purpose: This is the core error recovery engineering for production readiness. Without it, connection failures crash the server or leave Claude with unhelpful errors. The logger replaces all raw console.error calls with structured JSON that can be filtered and parsed.

Output: Three modified/created files -- logger.js (new), shared.js (enhanced with health check + reconnection), osc-client.js (reconnect method).
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-integration-polish/08-RESEARCH.md
@src/tools/shared.js
@src/osc-client.js
@src/logger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured JSON logger and add reconnect() to OscClient</name>
  <files>src/logger.js, src/osc-client.js</files>
  <action>
  Create `src/logger.js` with a simple structured JSON logger:
  - Export a `log(level, message, data)` function
  - Levels: error (0), warn (1), info (2), debug (3)
  - Read LOG_LEVEL from process.env (default: 'info')
  - Output format: `{"ts":"ISO-8601","level":"info","msg":"message",...data}` followed by newline
  - Write to `process.stderr.write()` -- NEVER console.log() (stdout is MCP transport)
  - This is ~15 lines of code, no external dependencies

  Then enhance `src/osc-client.js`:
  - Import `log` from `../logger.js` (note: logger is sibling to osc-client, NOT in tools/)
  - Wait -- actually logger.js is in src/ alongside osc-client.js, so import from `./logger.js`
  - Add `async reconnect(maxRetries = 3)` method to OscClient class:
    - Start delay at 500ms, double each attempt, cap at 5000ms
    - Each attempt: log warn, wait delay, close existing udpPort, create new UDPPort with same config, re-bind event handlers, call open(), run healthCheck()
    - If healthCheck succeeds: log info "Reconnected to Ableton", return true
    - If all retries fail: return false
    - Important: close() clears pending requests (already implemented), so reconnect safely handles in-flight queries
  - Replace `console.error` in handleError() with `log('error', ...)` call
  - Replace the comment about "production logger" in handleMessage() unhandled branch with `log('debug', 'Unhandled OSC message', { address })`
  </action>
  <verify>
  `node -e "import('./src/logger.js').then(m => m.log('info', 'test', {foo: 'bar'}))"` writes JSON to stderr.
  `node -e "import('./src/osc-client.js').then(m => { const c = new m.OscClient(); console.log(typeof c.reconnect) })"` prints "function".
  `node --test test/osc-client.test.js` still passes (existing tests unbroken).
  </verify>
  <done>
  logger.js exports log() function that writes structured JSON to stderr with level filtering.
  OscClient has reconnect() method with exponential backoff (500ms -> 1s -> 2s, cap 5s, 3 retries).
  All existing console.error calls in osc-client.js replaced with structured log() calls.
  Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add auto health check with promise lock and reconnection wiring to shared.js</name>
  <files>src/tools/shared.js</files>
  <action>
  Enhance `src/tools/shared.js` with auto health check and reconnection:

  1. Import `log` from `../logger.js`

  2. Add module-level state:
     - `let hasVerifiedConnection = false;`
     - `let healthCheckPromise = null;`

  3. Rewrite `ensureConnected()`:
     - Get client via getOscClient()
     - If not client.isReady, call client.open()
     - If !hasVerifiedConnection:
       - If !healthCheckPromise (no check in progress): create one via `client.ensureConnected().then(() => { hasVerifiedConnection = true; }).finally(() => { healthCheckPromise = null; })`
       - Store as healthCheckPromise
       - Await healthCheckPromise (this is the promise-lock pattern -- concurrent calls share one check)
     - Return client
     - Wrap the whole thing in try/catch: on connection error, attempt reconnection via `attemptReconnect(client)` -- if reconnect succeeds, return the new client; if fails, throw with clear troubleshooting message

  4. Add `attemptReconnect(client)` function (NOT exported, internal):
     - Call client.reconnect() -- if returns true, log info, resetConnectionState(), return client
     - If reconnect returns false: call resetClient() to clear singleton, throw error with troubleshooting message:
       "CONNECTION_LOST: Failed to reconnect to Ableton after 3 attempts.\nTroubleshooting:\n1. Ensure Ableton Live is running\n2. Check AbletonOSC is enabled in Preferences > Link/Tempo/MIDI\n3. Verify no other process is using UDP ports 11000/11001"

  5. Export `resetConnectionState()`:
     - Sets hasVerifiedConnection = false
     - Sets healthCheckPromise = null
     - Log info "Connection state reset, next call will re-verify"

  6. Keep existing exports: getOscClient, resetClient, setOscClient unchanged.
  </action>
  <verify>
  `node -e "import('./src/tools/shared.js').then(m => console.log(typeof m.resetConnectionState))"` prints "function".
  `node --test test/server.test.js` still passes.
  `node --test test/health.test.js` still passes.
  </verify>
  <done>
  ensureConnected() runs health check on first call per session with promise-lock (no race condition).
  Connection errors trigger reconnection before throwing.
  resetConnectionState() exported for use by error handlers.
  All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `node --test test/*.test.js` -- all existing tests still pass
- `LOG_LEVEL=debug node -e "import('./src/logger.js').then(m => { m.log('debug', 'debug msg'); m.log('info', 'info msg'); m.log('error', 'error msg') })"` -- all 3 messages appear on stderr
- `LOG_LEVEL=error node -e "import('./src/logger.js').then(m => { m.log('debug', 'debug msg'); m.log('info', 'info msg'); m.log('error', 'error msg') })"` -- only error message appears
- `node -e "import('./src/tools/shared.js').then(m => console.log(Object.keys(m).sort()))"` -- includes resetConnectionState
</verification>

<success_criteria>
1. Structured JSON logger works with level filtering via LOG_LEVEL env var
2. OscClient.reconnect() implements exponential backoff (500ms base, 2x multiplier, 5s cap, 3 retries)
3. ensureConnected() auto-checks health on first call with promise lock preventing duplicate checks
4. Connection failures trigger auto-reconnect before throwing
5. resetConnectionState() allows error handlers to force re-verification
6. All existing tests pass unchanged
7. Zero console.log() calls anywhere (stdout clean for MCP)
</success_criteria>

<output>
After completion, create `.planning/phases/08-integration-polish/08-01-SUMMARY.md`
</output>
