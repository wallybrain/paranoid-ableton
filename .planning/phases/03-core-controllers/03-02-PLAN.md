---
phase: 03-core-controllers
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/tools/track.js
  - src/tools/mixer.js
autonomous: true

must_haves:
  truths:
    - "Claude can list all regular tracks with full state (name, type, volume, pan, mute, solo, arm, device count)"
    - "Claude can create MIDI and audio tracks at any position or at end"
    - "Claude can delete tracks with two-step confirmation (first call shows contents, second deletes)"
    - "Claude can select, arm/disarm, and rename tracks"
    - "Claude can get/set volume in both dB and normalized formats"
    - "Claude can get/set pan using MIDI 0-127 convention"
    - "Claude can mute/unmute and solo/unsolo tracks"
    - "Claude can get/set send levels to return tracks"
  artifacts:
    - path: "src/tools/track.js"
      provides: "Track management tools (6 tools)"
      exports: ["tools", "handle"]
    - path: "src/tools/mixer.js"
      provides: "Mixer control tools (8 tools)"
      exports: ["tools", "handle"]
  key_links:
    - from: "src/tools/track.js"
      to: "src/tools/helpers.js"
      via: "imports resolveTrackIndex, buildTrackSnapshot, guardWrite, pendingDelete functions"
      pattern: "import.*from.*helpers"
    - from: "src/tools/mixer.js"
      to: "src/tools/helpers.js"
      via: "imports resolveTrackIndex, parseVolumeInput, parsePanInput, buildTrackSnapshot, guardWrite"
      pattern: "import.*from.*helpers"
    - from: "src/tools/track.js"
      to: "src/tools/shared.js"
      via: "ensureConnected() for OscClient access"
      pattern: "ensureConnected"
    - from: "src/tools/mixer.js"
      to: "src/tools/shared.js"
      via: "ensureConnected() for OscClient access"
      pattern: "ensureConnected"
---

<objective>
Create the track management module (6 tools for list, create, delete, select, arm, rename) and mixer module (8 tools for volume, pan, mute, solo, sends). These cover requirements TRCK-01 through TRCK-05 and MIX-01 through MIX-04.

Purpose: Track and mixer are the most-used controllers in a typical session. Together they give Claude full control over the session's track structure and mix state.

Output: Two new files (track.js, mixer.js) importing from helpers.js (Plan 01), ready for registry integration in Plan 03.
</objective>

<execution_context>
@/home/lwb3/.claude/get-shit-done/workflows/execute-plan.md
@/home/lwb3/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/lwb3/ableton-mcp/.planning/PROJECT.md
@/home/lwb3/ableton-mcp/.planning/ROADMAP.md
@/home/lwb3/ableton-mcp/.planning/phases/03-core-controllers/03-RESEARCH.md
@/home/lwb3/ableton-mcp/.planning/phases/03-core-controllers/03-CONTEXT.md
@/home/lwb3/ableton-mcp/.planning/phases/03-core-controllers/03-01-SUMMARY.md
@/home/lwb3/ableton-mcp/src/tools/health.js
@/home/lwb3/ableton-mcp/src/tools/helpers.js
@/home/lwb3/ableton-mcp/src/tools/shared.js
@/home/lwb3/ableton-mcp/src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create track.js domain module with 6 track management tools</name>
  <files>src/tools/track.js</files>
  <action>
Create `src/tools/track.js` following the health.js pattern (export `tools[]` and `async handle(name, args)`).

**Imports:**
- `ensureConnected` from `./shared.js`
- `resolveTrackIndex, buildTrackSnapshot, guardWrite, getPendingDelete, setPendingDelete, clearPendingDelete` from `./helpers.js`
- `TIMEOUTS` from `../osc-client.js`

**Tool definitions (6 tools):**

1. `track_list` -- List all regular tracks with full state. No args.
   Description: "List all tracks in the session with their properties. Note: only regular tracks (MIDI, audio) are listed. Return tracks and master track are not accessible via current AbletonOSC API."

2. `track_create` -- Create a new track. Args: `{type: 'midi'|'audio', index?: integer}` where index is 0-based insertion point (-1 or omit for end).
   Description: "Create a new MIDI or audio track. Specify index for insertion position (0-based), or omit/-1 to append at end."

3. `track_delete` -- Delete a track (two-step). Args: `{track: integer|string, confirm?: boolean}`.
   Description: "Delete a track. First call (no confirm) returns track contents as warning. Second call with confirm=true performs deletion. Track can be specified by index or name."

4. `track_select` -- Select a track in Ableton's UI. Args: `{track: integer|string}`.
   Description: "Select a track in Ableton's session view. Track can be specified by index or name."

5. `track_set_arm` -- Arm or disarm a track. Args: `{track: integer|string, armed: boolean}`.
   Description: "Arm or disarm a track for recording. Track can be specified by index or name."

6. `track_rename` -- Rename a track. Args: `{track: integer|string, name: string}`.
   Description: "Rename a track. Track can be specified by current index or current name."

**Handle function -- prefix check:** `if (!name.startsWith('track_')) return null;`

**Switch cases:**

- `track_list`:
  Query `/live/song/get/num_tracks` to get count. Then build snapshots for each track 0..numTracks-1 using `buildTrackSnapshot(client, i)`. Return array of track snapshots as JSON.
  Performance note: This makes many OSC queries (9 per track). For sessions with 20+ tracks this may be slow. Acceptable for Phase 3; optimize with `/live/song/get/track_data` bulk query in a future phase if needed.

- `track_create`:
  guardWrite check. Determine OSC address: `args.type === 'midi'` -> `/live/song/create_midi_track`, else `/live/song/create_audio_track`. Index arg: `args.index ?? -1` (default append). Send with `[index]` and TIMEOUTS.COMMAND. After creation, query `/live/song/get/num_tracks` to find new track index (if -1, new track is at numTracks-1). Build and return snapshot of the new track.

- `track_delete` (two-step per user locked decision):
  guardWrite check. Resolve track index via `resolveTrackIndex(client, args.track)`.

  **If confirm is NOT true:** Build track snapshot, store via `setPendingDelete(trackIndex, snapshot)`. Return the snapshot with a message: `"CONFIRM_DELETE: Track ${trackIndex} ('${snapshot.name}') will be deleted. Call track_delete again with confirm=true to proceed."` Do NOT set isError (this is informational, not an error).

  **If confirm IS true:** Check `getPendingDelete(trackIndex)` exists. If not, return error `DELETE_NOT_PENDING: No pending delete for track ${trackIndex}. Call track_delete without confirm first.` If exists, call `/live/song/delete_track` with `[trackIndex]` and TIMEOUTS.COMMAND. `clearPendingDelete(trackIndex)`. Return success message with the deleted track info from the stored snapshot.

- `track_select`:
  guardWrite check. Resolve track index. Call `/live/view/set/selected_track` with `[trackIndex]` and TIMEOUTS.COMMAND. Return snapshot of selected track.

- `track_set_arm`:
  guardWrite check. Resolve track index. Call `/live/track/set/arm` with `[trackIndex, args.armed ? 1 : 0]` and TIMEOUTS.COMMAND. Return snapshot of track.

- `track_rename`:
  guardWrite check. Resolve track index. Call `/live/track/set/name` with `[trackIndex, args.name]` and TIMEOUTS.COMMAND. Return snapshot of track (which will show new name).

**Error handling:** Wrap each case in try/catch. Return `TRACK_ERROR: ${err.message}` with isError true.

**Return track limitation:** Add a comment at the top noting that AbletonOSC's `/live/track/` only accesses `song.tracks` (regular tracks). Return tracks and master track require different API paths not available in current AbletonOSC.
  </action>
  <verify>
Run: `node -e "import('./src/tools/track.js').then(t => { console.log('tools:', t.tools.length); console.log('names:', t.tools.map(x=>x.name).join(', ')); console.log('handle type:', typeof t.handle); console.log('OK'); })"`

Expected: tools: 6, all 6 names listed, handle type: function, OK.

Test two-step delete state functions from helpers.js (pure state, no OSC needed):
Run: `node -e "import('./src/tools/helpers.js').then(h => { console.log('pending before:', h.getPendingDelete(0)); h.setPendingDelete(0, {name:'TestTrack', index:0}); console.log('pending after:', JSON.stringify(h.getPendingDelete(0))); h.clearPendingDelete(0); console.log('pending cleared:', h.getPendingDelete(0)); console.log('DELETE_STATE_OK'); })"`

Expected: pending before: undefined, pending after: {"name":"TestTrack","index":0}, pending cleared: undefined, DELETE_STATE_OK.
  </verify>
  <done>track.js exports 6 tool definitions and handle function. track_delete implements two-step confirmation. track_list returns full snapshots for all regular tracks. All tools accept track by index or name. Return track limitation documented. Two-step delete state management (setPendingDelete, getPendingDelete, clearPendingDelete) verified as working correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create mixer.js domain module with 8 mixer tools</name>
  <files>src/tools/mixer.js</files>
  <action>
Create `src/tools/mixer.js` following the health.js pattern (export `tools[]` and `async handle(name, args)`).

**Imports:**
- `ensureConnected` from `./shared.js`
- `resolveTrackIndex, parseVolumeInput, parsePanInput, normalizedToDb, floatPanToMidi, buildTrackSnapshot, guardWrite` from `./helpers.js`
- `TIMEOUTS` from `../osc-client.js`

**Tool definitions (8 tools):**

1. `mixer_get_volume` -- Get track volume. Args: `{track: integer|string}`.
   Description: "Get track volume. Returns both normalized (0.0-1.0) and dB values. Track by index or name."

2. `mixer_set_volume` -- Set track volume. Args: `{track: integer|string, volume: number|string}`.
   Description: "Set track volume. Accepts dB (e.g., '-6dB', '0dB', '+3dB') or normalized float (0.0 to 1.0). Track by index or name."

3. `mixer_get_pan` -- Get track pan. Args: `{track: integer|string}`.
   Description: "Get track pan position. Returns both float (-1.0 to 1.0) and MIDI (0-127) values. Track by index or name."

4. `mixer_set_pan` -- Set track pan. Args: `{track: integer|string, pan: integer}`.
   Description: "Set track pan position using MIDI convention: 0=hard left, 64=center, 127=hard right. Track by index or name."

5. `mixer_set_mute` -- Set track mute. Args: `{track: integer|string, muted: boolean}`.
   Description: "Mute or unmute a track. Track by index or name."

6. `mixer_set_solo` -- Set track solo. Args: `{track: integer|string, soloed: boolean}`.
   Description: "Solo or unsolo a track. Track by index or name."

7. `mixer_get_send` -- Get send level. Args: `{track: integer|string, send: integer}`.
   Description: "Get send level for a track. Send index is 0-based (0=Send A, 1=Send B, etc.). Track by index or name."

8. `mixer_set_send` -- Set send level. Args: `{track: integer|string, send: integer, level: number}`.
   Description: "Set send level for a track. Level is normalized 0.0-1.0. Send index is 0-based (0=Send A, 1=Send B). Track by index or name."

**Handle function -- prefix check:** `if (!name.startsWith('mixer_')) return null;`

**Switch cases:**

- `mixer_get_volume`:
  Resolve track index. Query `/live/track/get/volume` with `[trackIndex]`. Response is `[trackIndex, volume]`. Return `{track: trackIndex, volume: {normalized: volume, db: normalizedToDb(volume)}}`.

- `mixer_set_volume`:
  guardWrite check. Resolve track index. Convert input: `parseVolumeInput(args.volume)` to get normalized value. Call `/live/track/set/volume` with `[trackIndex, normalizedValue]` and TIMEOUTS.COMMAND. Return full track snapshot via `buildTrackSnapshot(client, trackIndex)`.

- `mixer_get_pan`:
  Resolve track index. Query `/live/track/get/panning` with `[trackIndex]`. Response is `[trackIndex, panning]`. Return `{track: trackIndex, pan: {normalized: panning, midi: floatPanToMidi(panning)}}`.

- `mixer_set_pan`:
  guardWrite check. Resolve track index. Convert input: `parsePanInput(args.pan)` to get float value. Call `/live/track/set/panning` with `[trackIndex, floatValue]` and TIMEOUTS.COMMAND. Return full track snapshot.

- `mixer_set_mute`:
  guardWrite check. Resolve track index. Call `/live/track/set/mute` with `[trackIndex, args.muted ? 1 : 0]` and TIMEOUTS.COMMAND. Return full track snapshot.

- `mixer_set_solo`:
  guardWrite check. Resolve track index. Call `/live/track/set/solo` with `[trackIndex, args.soloed ? 1 : 0]` and TIMEOUTS.COMMAND. Return full track snapshot.

- `mixer_get_send`:
  Resolve track index. Query `/live/track/get/send` with `[trackIndex, args.send]`. Response is `[trackIndex, sendIndex, value]`. Return `{track: trackIndex, send_index: args.send, level: value}`.

- `mixer_set_send`:
  guardWrite check. Resolve track index. Call `/live/track/set/send` with `[trackIndex, args.send, args.level]` and TIMEOUTS.COMMAND. Return full track snapshot.

**Response format:** All responses use `{content: [{type: 'text', text: JSON.stringify(data)}]}`. Write operations return full track snapshot per user locked decision. Read operations return just the requested value(s) in both native and human-friendly formats.

**Error handling:** Wrap each case in try/catch. Return `MIXER_ERROR: ${err.message}` with isError true.

**inputSchema details:** For each tool, define proper JSON Schema with `type: 'object'`, `properties` with descriptions, and `required` array. For the track property, use description "Track by 0-based index (integer) or name (string)" -- do NOT use oneOf for track since MCP clients handle it better as a generic description. Use `{}` (no type constraint) or just describe in the description field.

Actually, for simplicity and MCP compatibility, define the `track` property without oneOf -- just use `description` to explain it accepts index or name. The handler does runtime type checking via resolveTrackIndex. Same for volume (accepts number or string).
  </action>
  <verify>
Run: `node -e "import('./src/tools/mixer.js').then(m => { console.log('tools:', m.tools.length); console.log('names:', m.tools.map(x=>x.name).join(', ')); console.log('handle type:', typeof m.handle); console.log('OK'); })"`

Expected: tools: 8, all 8 names listed, handle type: function, OK.
  </verify>
  <done>mixer.js exports 8 tool definitions and handle function. Volume tools accept both dB and normalized input (per user decision). Pan tools use MIDI 0-127 convention (per user decision). Write operations return full track snapshots. Send tools use 0-based send index.</done>
</task>

</tasks>

<verification>
- `node -e "import('./src/tools/track.js').then(t => console.log('track OK'))"` -- no import errors
- `node -e "import('./src/tools/mixer.js').then(m => console.log('mixer OK'))"` -- no import errors
- track.js exports exactly 6 tools and 1 handle function
- mixer.js exports exactly 8 tools and 1 handle function
- Both modules import from helpers.js (created in Plan 01)
- No modifications to registry.js (deferred to Plan 03)
- Two-step delete state functions (setPendingDelete, getPendingDelete, clearPendingDelete) are importable and work correctly
</verification>

<success_criteria>
- track.js implements TRCK-01 through TRCK-05 with correct OSC addresses
- mixer.js implements MIX-01 through MIX-04 with correct OSC addresses
- Track references accept index or name (per user decision)
- Volume accepts dB or normalized (per user decision)
- Pan uses MIDI 0-127 (per user decision)
- track_delete uses two-step confirmation (per user decision)
- Write operations return full snapshots (per user decision)
- All write tools gated by read-only mode
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-controllers/03-02-SUMMARY.md`
</output>
