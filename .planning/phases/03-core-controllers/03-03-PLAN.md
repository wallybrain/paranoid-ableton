---
phase: 03-core-controllers
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/tools/scene.js
  - src/tools/registry.js
autonomous: true

must_haves:
  truths:
    - "Claude can list all scenes with their names and clip slot status"
    - "Claude can launch and stop scenes"
    - "Claude can launch and stop individual clips"
    - "Claude can create and rename scenes"
    - "Claude can undo/redo operations in Ableton"
    - "Claude can toggle read-only mode"
    - "Claude can batch multiple tool calls in a single request"
    - "All 34+ tools are registered and discoverable via MCP"
  artifacts:
    - path: "src/tools/scene.js"
      provides: "Scene and clip domain tools (7 tools)"
      exports: ["tools", "handle"]
    - path: "src/tools/registry.js"
      provides: "Updated registry with all 5 domain modules + utility tools"
      exports: ["getToolDefinitions", "handleToolCall"]
  key_links:
    - from: "src/tools/scene.js"
      to: "src/tools/helpers.js"
      via: "imports guardWrite and resolveTrackIndex"
      pattern: "import.*from.*helpers"
    - from: "src/tools/registry.js"
      to: "src/tools/transport.js"
      via: "imports transport module into modules array"
      pattern: "import.*transport"
    - from: "src/tools/registry.js"
      to: "src/tools/track.js"
      via: "imports track module into modules array"
      pattern: "import.*track"
    - from: "src/tools/registry.js"
      to: "src/tools/mixer.js"
      via: "imports mixer module into modules array"
      pattern: "import.*mixer"
    - from: "src/tools/registry.js"
      to: "src/tools/scene.js"
      via: "imports scene module into modules array"
      pattern: "import.*scene"
---

<objective>
Create the scene/clip domain module (7 tools), add utility tools (undo, redo, set_read_only, batch_commands), and wire ALL new domain modules into the registry. This completes Phase 3 -- after this plan, all ~34 tools are registered and callable via MCP.

Purpose: Scenes/clips complete the core controller surface. Utility tools (undo, read-only, batch) provide the safety and efficiency features the user locked as decisions. Registry wiring makes everything live.

Output: scene.js created, registry.js updated with all modules, utility tools integrated. Full Phase 3 tool surface operational.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/user/ableton-mcp/.planning/PROJECT.md
@/home/user/ableton-mcp/.planning/ROADMAP.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-RESEARCH.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-CONTEXT.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-01-SUMMARY.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-02-SUMMARY.md
@/home/user/ableton-mcp/src/tools/health.js
@/home/user/ableton-mcp/src/tools/helpers.js
@/home/user/ableton-mcp/src/tools/shared.js
@/home/user/ableton-mcp/src/tools/registry.js
@/home/user/ableton-mcp/src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scene.js domain module with 7 scene/clip tools</name>
  <files>src/tools/scene.js</files>
  <action>
Create `src/tools/scene.js` following the health.js pattern (export `tools[]` and `async handle(name, args)`).

**Imports:**
- `ensureConnected` from `./shared.js`
- `guardWrite, resolveTrackIndex` from `./helpers.js`
- `TIMEOUTS` from `../osc-client.js`

**Tool definitions (7 tools):**

1. `scene_list` -- List all scenes with clip slot info. No required args. Optional: `{include_clips?: boolean}` (default true).
   Description: "List all scenes with names. If include_clips is true (default), also shows which clip slots are populated across all tracks."

2. `scene_launch` -- Launch a scene. Args: `{scene: integer}` (0-based scene index).
   Description: "Launch a scene by index (0-based). All clips in the scene's row will be launched."

3. `scene_stop` -- Stop all clips. No args.
   Description: "Stop all playing clips in the session."

4. `clip_launch` -- Launch a clip. Args: `{track: integer|string, scene: integer}`.
   Description: "Launch a specific clip by track and scene position. Track by index or name, scene by 0-based index."

5. `clip_stop` -- Stop a clip. Args: `{track: integer|string, scene: integer}`.
   Description: "Stop a specific clip. Track by index or name, scene by 0-based index."

6. `scene_create` -- Create a new scene. Args: `{index?: integer}` (default -1, append at end).
   Description: "Create a new empty scene. Specify index for position (0-based), or omit to append at end."

7. `scene_rename` -- Rename a scene. Args: `{scene: integer, name: string}`.
   Description: "Rename a scene by index (0-based)."

**Handle function -- prefix check:** `if (!name.startsWith('scene_') && !name.startsWith('clip_')) return null;`

**Switch cases:**

- `scene_list`:
  Query `/live/song/get/num_scenes` for scene count. Query `/live/song/get/num_tracks` for track count.
  For each scene 0..numScenes-1: query `/live/scene/get/name` with `[sceneIndex]` to get name. Response format: `[sceneIndex, name]`.
  If include_clips is true (default): for each scene, for each track, query `/live/clip_slot/get/has_clip` with `[trackIndex, sceneIndex]`. Response: `[trackIndex, sceneIndex, 0|1]`.
  Build response: array of `{index, name, clips: [{track: trackIndex, has_clip: bool}]}`.
  Performance note: This is O(scenes * tracks) queries for clip status. For large sessions, this may be slow. Acceptable for Phase 3.

- `scene_launch`:
  guardWrite check. Call `/live/scene/fire` with `[args.scene]` and TIMEOUTS.COMMAND. Return `{launched: true, scene: args.scene}`.

- `scene_stop`:
  guardWrite check. Call `/live/song/stop_all_clips` with `[]` and TIMEOUTS.COMMAND. Return `{stopped: true}`.

- `clip_launch`:
  guardWrite check. Resolve track index via `resolveTrackIndex(client, args.track)`. Call `/live/clip/fire` with `[trackIndex, args.scene]` and TIMEOUTS.COMMAND. Return `{launched: true, track: trackIndex, scene: args.scene}`.

- `clip_stop`:
  guardWrite check. Resolve track index. Call `/live/clip/stop` with `[trackIndex, args.scene]` and TIMEOUTS.COMMAND. Return `{stopped: true, track: trackIndex, scene: args.scene}`.

- `scene_create`:
  guardWrite check. Call `/live/song/create_scene` with `[args.index ?? -1]` and TIMEOUTS.COMMAND. Query `/live/song/get/num_scenes` after to confirm. Return `{created: true, total_scenes: numScenes}`.

- `scene_rename`:
  guardWrite check. Call `/live/scene/set/name` with `[args.scene, args.name]` and TIMEOUTS.COMMAND. Return `{renamed: true, scene: args.scene, name: args.name}`.

**Error handling:** Wrap each case in try/catch. Return `SCENE_ERROR: ${err.message}` with isError true.
  </action>
  <verify>
Run: `node -e "import('./src/tools/scene.js').then(s => { console.log('tools:', s.tools.length); console.log('names:', s.tools.map(x=>x.name).join(', ')); console.log('handle type:', typeof s.handle); console.log('OK'); })"`

Expected: tools: 7, all 7 names listed, handle type: function, OK.
  </verify>
  <done>scene.js exports 7 tool definitions and handle function. Scene tools cover CLIP-01 through CLIP-04. Both scene_ and clip_ prefixes routed through same module. All write tools gated by read-only mode.</done>
</task>

<task type="auto">
  <name>Task 2: Update registry.js with all domain modules and add utility tools (undo, redo, set_read_only, batch_commands)</name>
  <files>src/tools/registry.js</files>
  <action>
Update `src/tools/registry.js` to import and register ALL new domain modules, and add utility tool handling.

**Step 1: Add imports for all new modules:**
```javascript
import * as health from './health.js';
import * as transport from './transport.js';
import * as track from './track.js';
import * as mixer from './mixer.js';
import * as scene from './scene.js';
```

**Step 2: Update modules array:**
```javascript
const modules = [health, transport, track, mixer, scene];
```

**Step 3: Add utility tool definitions directly in registry.js** (these are cross-cutting concerns, not domain-specific):

Add a `utilityTools` array with 4 tool definitions:

1. `undo` -- No args. Description: "Undo the last action in Ableton Live."
2. `redo` -- No args. Description: "Redo the last undone action in Ableton Live."
3. `set_read_only` -- Args: `{enabled: boolean}`. Description: "Toggle read-only mode. When enabled, all write operations are blocked. Useful for exploring a session without accidental changes."
4. `batch_commands` -- Args: `{commands: array of {tool: string, args?: object}, stop_on_error?: boolean}`. Description: "Execute multiple tool calls in sequence. Reduces round-trips for multi-step operations like creating several tracks and setting their properties. When stop_on_error is true (default), execution stops on first failure and returns partial results. When stop_on_error is false, all commands execute regardless of failures. Results returned as array."

   The `stop_on_error` parameter schema:
   ```json
   "stop_on_error": {
     "type": "boolean",
     "description": "If true (default), stop executing on first failure and return partial results. If false, continue executing all commands regardless of failures.",
     "default": true
   }
   ```

**Step 4: Update getToolDefinitions():**
```javascript
export function getToolDefinitions() {
  const tools = [
    ...modules.flatMap(m => m.tools),
    ...utilityTools
  ];
  // existing duplicate check...
  return tools;
}
```

**Step 5: Add utility handler in handleToolCall:**

Before the module iteration loop, handle utility tools:

```javascript
export async function handleToolCall(name, args) {
  // Utility tools handled directly
  switch (name) {
    case 'undo': {
      const guard = guardWrite('undo');
      if (guard) return guard;
      const client = await ensureConnected();
      await client.query('/live/song/undo', [], TIMEOUTS.COMMAND);
      return { content: [{ type: 'text', text: JSON.stringify({ undone: true }) }] };
    }
    case 'redo': {
      const guard = guardWrite('redo');
      if (guard) return guard;
      const client = await ensureConnected();
      await client.query('/live/song/redo', [], TIMEOUTS.COMMAND);
      return { content: [{ type: 'text', text: JSON.stringify({ redone: true }) }] };
    }
    case 'set_read_only': {
      setReadOnly(args.enabled);
      return { content: [{ type: 'text', text: JSON.stringify({ read_only: isReadOnly() }) }] };
    }
    case 'batch_commands': {
      const stopOnError = args.stop_on_error !== false; // default true
      const results = [];
      for (const cmd of args.commands) {
        // Prevent recursive batch calls
        if (cmd.tool === 'batch_commands') {
          results.push({ tool: cmd.tool, success: false, error: 'BATCH_RECURSION: batch_commands cannot be nested' });
          if (stopOnError) break;
          continue;
        }
        try {
          const result = await handleToolCall(cmd.tool, cmd.args || {});
          const success = !result.isError;
          results.push({ tool: cmd.tool, success, result: JSON.parse(result.content[0].text) });
          if (!success && stopOnError) break;
        } catch (err) {
          results.push({ tool: cmd.tool, success: false, error: err.message });
          if (stopOnError) break;
        }
      }
      return { content: [{ type: 'text', text: JSON.stringify({ batch_results: results, stopped_early: stopOnError && results.length < args.commands.length }) }] };
    }
  }

  // Domain module dispatch (existing pattern)
  for (const mod of modules) {
    const result = await mod.handle(name, args);
    if (result !== null) return result;
  }

  return {
    content: [{ type: 'text', text: `UNKNOWN_TOOL: No handler for tool '${name}'` }],
    isError: true
  };
}
```

**Additional imports needed in registry.js:**
- `ensureConnected` from `./shared.js`
- `guardWrite, isReadOnly, setReadOnly` from `./helpers.js`
- `TIMEOUTS` from `../osc-client.js`

**batch_commands safety:** batch_commands itself is NOT gated by read-only mode -- individual commands within the batch will be gated by their own handlers. batch_commands prevents recursion: if any cmd.tool === 'batch_commands', it records a BATCH_RECURSION error for that entry. When stop_on_error is true (default), this also halts the batch. When stop_on_error is false, it skips the recursive call and continues with remaining commands.

**Preserve existing patterns:** Keep the duplicate tool name detection in getToolDefinitions(). Keep the UNKNOWN_TOOL fallback.
  </action>
  <verify>
Run these checks in sequence:

1. Tool count and names:
   `node -e "import('./src/tools/registry.js').then(r => { const tools = r.getToolDefinitions(); console.log('Total tools:', tools.length); console.log('Names:', tools.map(t=>t.name).join(', ')); console.log('OK'); })"`
   Expected: Total tools should be approximately 32-35 (1 health + 10 transport + 6 track + 8 mixer + 7 scene + 4 utility). All names printed.

2. No duplicate names:
   `node -e "import('./src/tools/registry.js').then(r => { const tools = r.getToolDefinitions(); const names = tools.map(t=>t.name); const unique = new Set(names); if (names.length !== unique.size) console.log('DUPLICATE NAMES'); else console.log('No duplicates'); })"`
   Expected: "No duplicates"

3. Unknown tool fallback:
   `node -e "import('./src/tools/registry.js').then(r => r.handleToolCall('nonexistent', {}).then(res => console.log(res.content[0].text)))"`
   Expected: "UNKNOWN_TOOL: No handler for tool 'nonexistent'"

4. set_read_only returns correct state:
   `node -e "import('./src/tools/registry.js').then(r => r.handleToolCall('set_read_only', {enabled: true}).then(res => { const data = JSON.parse(res.content[0].text); console.log('read_only:', data.read_only); return r.handleToolCall('set_read_only', {enabled: false}); }).then(res => { const data = JSON.parse(res.content[0].text); console.log('read_only after disable:', data.read_only); console.log('SET_READ_ONLY_OK'); }))"`
   Expected: read_only: true, read_only after disable: false, SET_READ_ONLY_OK.

5. batch_commands blocks recursion:
   `node -e "import('./src/tools/registry.js').then(r => r.handleToolCall('batch_commands', {commands: [{tool: 'batch_commands', args: {commands: []}}]}).then(res => { const data = JSON.parse(res.content[0].text); console.log('recursion blocked:', data.batch_results[0].error); console.log('BATCH_RECURSION_OK'); }))"`
   Expected: recursion blocked: BATCH_RECURSION: batch_commands cannot be nested, BATCH_RECURSION_OK.
  </verify>
  <done>registry.js imports all 5 domain modules. Utility tools (undo, redo, set_read_only, batch_commands) handled directly in registry. getToolDefinitions() returns all ~36 tools. handleToolCall() routes to utility handlers first, then domain modules. No duplicate tool names. batch_commands prevents recursion and supports stop_on_error parameter (default true) to halt on first failure. set_read_only returns current read-only state. All utility behaviors verified.</done>
</task>

</tasks>

<verification>
- All tool definitions load without import errors: `node -e "import('./src/tools/registry.js').then(r => console.log(r.getToolDefinitions().length, 'tools registered'))"`
- No duplicate tool names in registry
- MCP server starts: `timeout 3 node src/index.js 2>&1 || true` (will exit due to stdin, but should not crash on import)
- Tool count matches expected: 1 (health) + 10 (transport) + 6 (track) + 8 (mixer) + 7 (scene) + 4 (utility) = 36 tools
- set_read_only toggles state and returns correct read_only boolean
- batch_commands with nested batch_commands returns BATCH_RECURSION error
- batch_commands with stop_on_error=true halts on first failure
- Verify all requirement coverage:
  - TRNS-01: transport_play, transport_stop, transport_continue
  - TRNS-02: transport_record
  - TRNS-03: transport_get_tempo, transport_set_tempo
  - TRNS-04: transport_get_position, transport_set_position
  - TRNS-05: transport_get_metronome, transport_set_metronome
  - TRNS-06: KNOWN LIMITATION (AbletonOSC gap)
  - TRCK-01: track_list
  - TRCK-02: track_create, track_delete
  - TRCK-03: track_select
  - TRCK-04: track_set_arm
  - TRCK-05: track_rename
  - MIX-01: mixer_get_volume, mixer_set_volume
  - MIX-02: mixer_get_pan, mixer_set_pan
  - MIX-03: mixer_set_mute, mixer_set_solo
  - MIX-04: mixer_get_send, mixer_set_send
  - CLIP-01: scene_list (with clip status)
  - CLIP-02: scene_launch, scene_stop
  - CLIP-03: clip_launch, clip_stop
  - CLIP-04: scene_create, scene_rename
  - Safety: undo, redo, set_read_only, batch_commands
</verification>

<success_criteria>
- scene.js implements CLIP-01 through CLIP-04
- Utility tools (undo, redo, set_read_only, batch_commands) registered and functional
- batch_commands executes sub-commands sequentially with stop_on_error support (default true stops on first failure, false continues all)
- batch_commands prevents recursive nesting
- set_read_only returns the current read_only state after toggling
- All ~36 tools registered in registry without duplicates
- MCP server starts without errors
- Every requirement from TRNS-01 through CLIP-04 has at least one tool (except TRNS-06 known limitation)
- All user locked decisions implemented: domain prefix naming, separate read/write tools, two-step delete, dB+normalized volume, MIDI pan, index+name track refs, relative tempo, full snapshots on write, read-only mode, undo, batch_commands
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-controllers/03-03-SUMMARY.md`
</output>
