---
phase: 03-core-controllers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools/helpers.js
  - src/tools/transport.js
autonomous: true

must_haves:
  truths:
    - "Volume dB values convert correctly to normalized floats (e.g., -6dB -> ~0.425, 0dB -> 0.85)"
    - "Pan MIDI 0-127 converts to float -1.0 to 1.0 (64 -> 0.0 center)"
    - "Track name lookup resolves to correct 0-based index via OSC query"
    - "Tempo relative inputs parse correctly ('+5', '-10', 'double', 'half')"
    - "Transport tools can start/stop/continue playback and return state snapshots"
    - "Transport tools can get/set tempo, position, and metronome"
  artifacts:
    - path: "src/tools/helpers.js"
      provides: "Value conversion, track resolution, snapshot builders, read-only gating"
      exports: ["dbToNormalized", "normalizedToDb", "parseVolumeInput", "midiPanToFloat", "floatPanToMidi", "resolveTrackIndex", "parseTempoInput", "buildTransportSnapshot", "buildTrackSnapshot", "isReadOnly", "setReadOnly", "guardWrite"]
    - path: "src/tools/transport.js"
      provides: "Transport domain tools (10 tools)"
      exports: ["tools", "handle"]
  key_links:
    - from: "src/tools/helpers.js"
      to: "src/osc-client.js"
      via: "resolveTrackIndex and snapshot builders call client.query()"
      pattern: "client\\.query\\("
    - from: "src/tools/transport.js"
      to: "src/tools/helpers.js"
      via: "imports parseTempoInput, buildTransportSnapshot, guardWrite"
      pattern: "import.*from.*helpers"
    - from: "src/tools/transport.js"
      to: "src/tools/shared.js"
      via: "ensureConnected() for lazy OscClient access"
      pattern: "ensureConnected"
---

<objective>
Create the shared helpers module (value conversion, track resolution, snapshot builders, safety guards) and the transport domain module (10 tools for playback, recording, tempo, position, metronome).

Purpose: Helpers.js is the foundation for ALL domain modules in this phase -- every tool that handles volume, pan, track references, or tempo depends on it. Transport is the first domain module, validating the pattern before track/mixer/scene follow.

Output: Two new files (helpers.js, transport.js) ready for registry integration in Plan 03.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/user/ableton-mcp/.planning/PROJECT.md
@/home/user/ableton-mcp/.planning/ROADMAP.md
@/home/user/ableton-mcp/.planning/STATE.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-RESEARCH.md
@/home/user/ableton-mcp/.planning/phases/03-core-controllers/03-CONTEXT.md
@/home/user/ableton-mcp/src/tools/health.js
@/home/user/ableton-mcp/src/tools/shared.js
@/home/user/ableton-mcp/src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create helpers.js with value conversion, track resolution, snapshot builders, and safety guards</name>
  <files>src/tools/helpers.js</files>
  <action>
Create `src/tools/helpers.js` with these exports:

**Volume conversion (dB <-> normalized 0.0-1.0):**
- `dbToNormalized(db)` -- returns float 0.0-1.0. -70 or below returns 0.0. 0dB = 0.85 (unity). +6dB = 1.0. Formula: below 0dB use `0.85 * Math.pow(10, db/20)`, 0-6dB use linear `0.85 + (db/6)*0.15`. Clamp result to [0.0, 1.0].
- `normalizedToDb(value)` -- inverse. Below 1e-7 returns -Infinity. Below 0.85 use `20 * Math.log10(value/0.85)`. Above 0.85 use `((value-0.85)/0.15)*6`. Cap at +6.
- `parseVolumeInput(input)` -- if string ending in "db" (case-insensitive), parse float and convert via dbToNormalized. If "-inf" or "-infinity", return 0.0. If number 0.0-1.0, return as-is. If number >1 or <0, throw INVALID_VOLUME error.

**Pan conversion (MIDI 0-127 <-> float -1.0 to 1.0):**
- `midiPanToFloat(midiValue)` -- `(midiValue - 64) / 64`. Clamp input to 0-127 first.
- `floatPanToMidi(floatValue)` -- `Math.round(floatValue * 64 + 64)`. Clamp result to 0-127.
- `parsePanInput(input)` -- accept integer 0-127 (MIDI convention per user decision). Validate range, convert to float via midiPanToFloat.

**Track resolution:**
- `resolveTrackIndex(client, trackRef)` -- if number, return as-is (0-based index per user decision). If string, query `/live/song/get/num_tracks`, then `/live/song/get/track_data` with `[0, numTracks, 'track.name']` to get all names. Find matching name (case-sensitive). Throw `TRACK_NOT_FOUND: No track named "${trackRef}"` if not found. (Use individual name queries via a loop if track_data parsing proves complex -- see Pitfall 5 in research.)

**Tempo parsing:**
- `parseTempoInput(input, currentTempo)` -- if number, return as-is (absolute BPM). If string: 'double' -> currentTempo*2, 'half' -> currentTempo/2, starts with '+'/'-' -> currentTempo+parseFloat(str), else parseFloat. Validate result is 20-999 BPM, throw INVALID_TEMPO if not.

**Snapshot builders (take `client` as parameter, NOT importing from shared.js -- callers pass the client):**
- `buildTransportSnapshot(client)` -- query tempo, is_playing, current_song_time, metronome, signature_numerator, signature_denominator, session_record_status from `/live/song/get/` addresses. Return structured object: `{tempo, is_playing: bool, recording: bool, current_time, metronome: bool, time_signature: "N/D"}`.
- `buildTrackSnapshot(client, trackIndex)` -- query name, volume, panning, mute, solo, arm, has_midi_input, has_audio_input, num_devices from `/live/track/get/` addresses (each takes `[trackIndex]` as arg). Return: `{index, name, type: 'midi'|'audio'|'unknown', volume: {normalized, db}, pan: {normalized, midi}, mute: bool, solo: bool, arm: bool, device_count}`. Use normalizedToDb and floatPanToMidi for the human-readable values.

**Read-only mode gating:**
- Module-level `let readOnlyMode = false;`
- `isReadOnly()` -- returns boolean
- `setReadOnly(enabled)` -- sets boolean
- `guardWrite(toolName)` -- if readOnlyMode, return MCP error response `{content: [{type:'text', text: 'READ_ONLY: Tool "${toolName}" blocked. Read-only mode is active. Use set_read_only(false) to disable.'}], isError: true}`. If not read-only, return null (caller proceeds).

**Two-step delete state:**
- Module-level `const pendingDeletes = new Map();`
- `getPendingDelete(trackIndex)` -- returns stored snapshot or undefined
- `setPendingDelete(trackIndex, snapshot)` -- stores snapshot
- `clearPendingDelete(trackIndex)` -- removes entry
- `clearAllPendingDeletes()` -- clears map

All conversion functions must be pure (no side effects, no async). Snapshot builders are async (they query OSC). Track resolution is async. Read-only and delete state are module-level singletons.

Add a comment at top noting volume unity point (0.85 = 0dB) is from community implementation, needs empirical verification.
  </action>
  <verify>
Run: `node -e "import('./src/tools/helpers.js').then(h => { console.log('dB->norm:', h.dbToNormalized(-6)); console.log('norm->dB:', h.normalizedToDb(0.85)); console.log('pan:', h.midiPanToFloat(64)); console.log('tempo:', h.parseTempoInput('+5', 120)); console.log('readonly:', h.isReadOnly()); console.log('OK'); })"`

Expected: dB->norm outputs ~0.425, norm->dB outputs ~0, pan outputs 0, tempo outputs 125, readonly outputs false, ends with OK.
  </verify>
  <done>helpers.js exports all conversion functions, snapshot builders, track resolver, read-only guard, and two-step delete state. Pure conversion functions return correct values for edge cases (silence, max volume, center pan, relative tempo).</done>
</task>

<task type="auto">
  <name>Task 2: Create transport.js domain module with 10 transport tools</name>
  <files>src/tools/transport.js</files>
  <action>
Create `src/tools/transport.js` following the exact pattern from health.js (export `tools[]` and `async handle(name, args)`).

**Tool definitions (10 tools):**

1. `transport_play` -- Start playback. No args. Description: "Start playback from current position."
2. `transport_stop` -- Stop playback. No args. Description: "Stop playback. Also stops recording if active (per design decision: just stop, no warning)."
3. `transport_continue` -- Continue playback. No args. Description: "Continue playback from where it was stopped."
4. `transport_record` -- Start session recording. No args. Description: "Toggle session recording. Checks current record status first -- only toggles if not already recording."
5. `transport_get_tempo` -- Get current tempo. No args. Description: "Get current session tempo in BPM."
6. `transport_set_tempo` -- Set tempo. Args: `{tempo}` where tempo is number (BPM) or string ('+5', '-10', 'double', 'half'). Description: "Set session tempo. Accepts absolute BPM (number) or relative change ('+5', '-10', 'double', 'half')."
7. `transport_get_position` -- Get current position. No args. Description: "Get current playback position in beats."
8. `transport_set_position` -- Set position. Args: `{position}` (number, beats). Description: "Set playback position in beats."
9. `transport_get_metronome` -- Get metronome state. No args. Description: "Get metronome on/off state."
10. `transport_set_metronome` -- Set metronome. Args: `{enabled}` (boolean). Description: "Enable or disable the metronome."

**Handle function:**
- Prefix check: `if (!name.startsWith('transport_')) return null;`
- Import `ensureConnected` from `./shared.js`
- Import `parseTempoInput, buildTransportSnapshot, guardWrite` from `./helpers.js`
- Import `TIMEOUTS` from `../osc-client.js`

**Switch cases:**

- `transport_play`: guardWrite check, then `client.query('/live/song/start_playing', [], TIMEOUTS.COMMAND)`, then `buildTransportSnapshot(client)`, return JSON snapshot.
- `transport_stop`: guardWrite check, then `client.query('/live/song/stop_playing', [], TIMEOUTS.COMMAND)`, then snapshot.
- `transport_continue`: guardWrite check, then `client.query('/live/song/continue_playing', [], TIMEOUTS.COMMAND)`, then snapshot.
- `transport_record`: guardWrite check. Query `/live/song/get/session_record_status` first. If already recording (value is 1 or 2), return snapshot with note "Already recording". If not, call `/live/song/trigger_session_record` with TIMEOUTS.COMMAND, then snapshot. This avoids Pitfall 6 (toggle accidentally stopping recording).
- `transport_get_tempo`: query `/live/song/get/tempo`, return `{tempo: value}`.
- `transport_set_tempo`: guardWrite check. Get current tempo first via `/live/song/get/tempo`. Parse input with `parseTempoInput(args.tempo, currentTempo)`. Set via `/live/song/set/tempo` with `[newTempo]` (must be float). Return snapshot.
- `transport_get_position`: query `/live/song/get/current_song_time`, return `{position_beats: value}`.
- `transport_set_position`: guardWrite check. Set via `/live/song/set/current_song_time` with `[args.position]`. Return snapshot.
- `transport_get_metronome`: query `/live/song/get/metronome`, return `{metronome: !!value}`.
- `transport_set_metronome`: guardWrite check. Set via `/live/song/set/metronome` with `[args.enabled ? 1 : 0]`. Return snapshot.

**Response format (per discretion: structured JSON):**
All responses use `{content: [{type: 'text', text: JSON.stringify(data)}]}`.
Write operations return the full transport snapshot (per user locked decision).
Read operations return just the requested value.

**Error handling:** Wrap each case in try/catch. On error, use OscClient's classifyError pattern if available, or return `{content: [{type:'text', text: 'TRANSPORT_ERROR: ${err.message}'}], isError: true}`.

**TRNS-06 gap:** Do NOT implement transport_get_song_name or transport_save. Add a comment noting AbletonOSC does not expose these operations. They are a known limitation documented in research.
  </action>
  <verify>
Run: `node -e "import('./src/tools/transport.js').then(t => { console.log('tools:', t.tools.length); console.log('names:', t.tools.map(x=>x.name).join(', ')); console.log('handle type:', typeof t.handle); console.log('OK'); })"`

Expected: tools: 10, lists all 10 tool names, handle type: function, OK.
  </verify>
  <done>transport.js exports 10 tool definitions and a handle function. Write tools check guardWrite before executing. transport_record checks current status before toggling (Pitfall 6). All write operations return full transport snapshot. TRNS-06 gap documented as comment.</done>
</task>

</tasks>

<verification>
- `node -e "import('./src/tools/helpers.js').then(h => console.log('helpers OK'))"` -- no import errors
- `node -e "import('./src/tools/transport.js').then(t => console.log('transport OK'))"` -- no import errors
- helpers.js exports at least 12 functions (conversions + builders + guards + delete state)
- transport.js exports exactly 10 tools and 1 handle function
- No modifications to existing files (registry.js updated in Plan 03)
</verification>

<success_criteria>
- helpers.js provides all value conversion, track resolution, snapshot building, and safety gating needed by ALL domain modules
- transport.js implements all transport requirements (TRNS-01 through TRNS-05) with correct OSC addresses
- TRNS-06 documented as known limitation
- Write operations gated by read-only mode
- transport_record avoids Pitfall 6 (toggle behavior) by checking status first
- All responses use structured JSON format
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-controllers/03-01-SUMMARY.md`
</output>
