---
phase: 02-mcp-server-shell
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - test/server.test.js
  - test/health.test.js
autonomous: true

must_haves:
  truths:
    - "Server registers ableton_status in tool list"
    - "Health tool returns connected:true when OscClient reports healthy"
    - "Health tool returns isError:true with CONNECTION_FAILED when Ableton is not reachable"
    - "Health tool returns isError:true with TIMEOUT when health check times out"
    - "Health tool returns isError:true with PORT_CONFLICT when port is in use"
    - "Unknown tool calls return isError:true with UNKNOWN_TOOL"
    - "All tests pass with node --test"
  artifacts:
    - path: "test/server.test.js"
      provides: "MCP server registration and tool dispatch tests"
      min_lines: 40
    - path: "test/health.test.js"
      provides: "ableton_status tool behavior tests with mocked OscClient"
      min_lines: 80
  key_links:
    - from: "test/server.test.js"
      to: "src/tools/registry.js"
      via: "import getToolDefinitions, handleToolCall"
      pattern: "import.*registry"
    - from: "test/health.test.js"
      to: "src/tools/health.js"
      via: "import handle, tools"
      pattern: "import.*health"
    - from: "test/health.test.js"
      to: "src/tools/shared.js"
      via: "import resetClient to inject mock"
      pattern: "import.*shared"
---

<objective>
Write unit tests for the MCP server framework and health tool, proving the full pipeline works with mocked OscClient.

Purpose: Validate that tool registration, dispatch, health checking, and error propagation all work correctly before attempting to connect to a real Ableton instance. Tests mock at the OscClient boundary (not UDP layer) since Phase 1 already tests the UDP layer thoroughly.

Output: Test suite covering server registration, tool dispatch, health tool success/failure cases, and error code mapping.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-server-shell/02-RESEARCH.md
@.planning/phases/02-mcp-server-shell/02-01-SUMMARY.md
@src/index.js
@src/tools/registry.js
@src/tools/shared.js
@src/tools/health.js
@src/osc-client.js
@test/osc-client.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for tool registry and server wiring</name>
  <files>test/server.test.js</files>
  <action>
Create `test/server.test.js` using the same test patterns established in Phase 1 (node:test, node:assert/strict).

Mock boundary: Mock at OscClient level via shared.js resetClient(). Do NOT import or test the Server class directly (that is MCP SDK's responsibility). Test the registry and handler logic.

Test cases:

**Tool Registration:**
- `getToolDefinitions()` returns an array
- `getToolDefinitions()` includes ableton_status tool
- ableton_status tool has name, description, and inputSchema fields
- inputSchema has type "object"

**Tool Dispatch:**
- `handleToolCall('ableton_status', {})` returns an object with `content` array (mock OscClient to succeed)
- `handleToolCall('nonexistent_tool', {})` returns isError:true with UNKNOWN_TOOL error code
- `handleToolCall('ableton_status', {})` content[0].type is "text"

**Pattern for mocking OscClient in registry tests:**
```javascript
import { resetClient } from '../src/tools/shared.js';

// Before each test that calls handleToolCall:
// 1. resetClient() to clear singleton
// 2. Use a mock module approach OR test health.js handle() directly
```

Since registry.js delegates to health.js which calls shared.js, the simplest approach is:
- For registration tests: just test getToolDefinitions() (no mock needed)
- For dispatch tests: mock via shared.js resetClient + re-assign, OR test that unknown tools return errors (no OscClient needed)

Keep tests focused on REGISTRY behavior. Health tool behavior tests go in health.test.js.
  </action>
  <verify>
    Run `node --test test/server.test.js` -- all tests must pass.
  </verify>
  <done>
    - test/server.test.js covers tool registration (definitions include ableton_status) and dispatch (unknown tool error)
    - All tests pass with node --test
    - Test patterns match Phase 1 conventions (node:test, describe/it blocks)
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for ableton_status health tool</name>
  <files>test/health.test.js</files>
  <action>
Create `test/health.test.js` testing the health tool's handle() function with a mocked OscClient.

Mock strategy: Create a mock OscClient object with controllable behavior. Use shared.js to inject it:
- Import `resetClient` from `../src/tools/shared.js`
- After resetClient(), the next call to getOscClient() will create a new instance
- Alternative: directly test health.js handle() by mocking the shared module imports

The cleanest approach: Use a mock OscClient factory. Before each test:
1. Call `resetClient()` to clear the singleton
2. Create a mock OscClient with the needed behavior
3. Override the module's internal state (or use node:test mock capabilities)

If direct module mocking is complex, an alternative is to refactor shared.js to accept an injected client for testing. The `resetClient()` export exists for this purpose. You could add a `setOscClient(client)` export to shared.js if needed for testability. This is acceptable -- it is a minimal change.

**If you add setOscClient to shared.js:** Add it as: `export function setOscClient(client) { oscClient = client; }`. This replaces the singleton for testing.

Test cases:

**Success Path:**
- When OscClient is ready and healthCheck() returns true:
  - handle() returns content with connected:true
  - Response includes host, sendPort, receivePort
  - isError is NOT set (or is false/undefined)
  - Content type is "text"
  - Content text is valid JSON

**Connection Not Established:**
- When ensureConnected() / open() throws (simulating Ableton not running):
  - handle() returns isError:true
  - Error text starts with CONNECTION_FAILED or appropriate error code
  - Error text is concise (not multi-line troubleshooting guide)

**Health Check Fails:**
- When OscClient is ready but healthCheck() returns false:
  - handle() returns isError:true
  - Error text contains CONNECTION_FAILED

**Timeout:**
- When OscClient.open() or healthCheck() throws a timeout error:
  - handle() returns isError:true
  - Error text starts with TIMEOUT

**Port Conflict:**
- When OscClient.open() throws EADDRINUSE error:
  - handle() returns isError:true
  - Error text starts with PORT_CONFLICT

**Not Our Tool:**
- `handle('other_tool', {})` returns null

**Mock OscClient shape:**
```javascript
const mockClient = {
  isReady: true,
  host: '127.0.0.1',
  sendPort: 11001,
  receivePort: 11000,
  async open() { this.isReady = true; },
  async healthCheck() { return true; },
  classifyError(err) {
    // Return appropriate classification based on test scenario
    return { type: 'TIMEOUT', message: err.message, recoverable: true };
  }
};
```

Vary mock behavior per test case by changing `healthCheck()` return value, making `open()` throw, etc.
  </action>
  <verify>
    Run `node --test test/health.test.js` -- all tests must pass.
    Run `npm test` -- ALL tests (osc-client + server + health) must pass.
  </verify>
  <done>
    - test/health.test.js covers: success, connection failure, health check failure, timeout, port conflict, unknown tool
    - All error responses have isError:true with short ERROR_CODE: context format
    - Success response has valid JSON with connected:true and port info
    - npm test runs all test files and all pass
  </done>
</task>

</tasks>

<verification>
1. `node --test test/server.test.js` -- all pass
2. `node --test test/health.test.js` -- all pass
3. `npm test` -- all test files pass (osc-client.test.js + server.test.js + health.test.js)
4. No tests import or bind to real UDP ports
5. Error codes in tests match: CONNECTION_FAILED, TIMEOUT, PORT_CONFLICT, UNKNOWN_TOOL, INTERNAL_ERROR
</verification>

<success_criteria>
- Full test suite validates MCP server framework and health tool
- Tests mock at OscClient boundary (not UDP layer)
- All error code paths are exercised
- npm test passes across all test files (Phase 1 + Phase 2)
- Test patterns are consistent with Phase 1 conventions
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-server-shell/02-02-SUMMARY.md`
</output>
