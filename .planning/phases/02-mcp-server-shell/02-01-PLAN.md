---
phase: 02-mcp-server-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/index.js
  - src/tools/shared.js
  - src/tools/registry.js
  - src/tools/health.js
autonomous: true

must_haves:
  truths:
    - "MCP server starts via stdio transport without errors when Ableton is not running"
    - "Server lists ableton_status tool via ListTools request"
    - "ableton_status tool returns connection info when called"
    - "Errors from OSC layer surface as isError:true with short error codes"
  artifacts:
    - path: "src/index.js"
      provides: "MCP server entry point with stdio transport"
      contains: "Server.*paranoid-ableton"
    - path: "src/tools/registry.js"
      provides: "Tool aggregation from domain modules"
      exports: ["getToolDefinitions", "handleToolCall"]
    - path: "src/tools/shared.js"
      provides: "Lazy OscClient singleton"
      exports: ["getOscClient", "ensureConnected"]
    - path: "src/tools/health.js"
      provides: "ableton_status tool definition and handler"
      contains: "ableton_status"
  key_links:
    - from: "src/index.js"
      to: "src/tools/registry.js"
      via: "import getToolDefinitions, handleToolCall"
      pattern: "import.*registry"
    - from: "src/tools/registry.js"
      to: "src/tools/health.js"
      via: "import * as health"
      pattern: "import.*health"
    - from: "src/tools/health.js"
      to: "src/tools/shared.js"
      via: "import ensureConnected/getOscClient"
      pattern: "import.*shared"
    - from: "src/tools/shared.js"
      to: "src/osc-client.js"
      via: "import OscClient"
      pattern: "import.*osc-client"
---

<objective>
Create the MCP server framework that bridges Claude Code to Ableton via the Phase 1 OSC client.

Purpose: This is the core infrastructure that all future phases (3-8) will build on. Every domain tool (transport, tracks, mixer, etc.) will plug into this framework. The server must start cleanly via stdio even when Ableton is not running (lazy OSC connection), register tools via the user's established low-level Server pattern, and propagate errors with short error codes.

Output: Working MCP server with `ableton_status` health tool, lazy OscClient singleton, and domain-module registry pattern ready for Phase 3+ tool additions.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-mcp-server-shell/02-RESEARCH.md
@.planning/phases/02-mcp-server-shell/02-CONTEXT.md
@src/osc-client.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP SDK and create server entry point with tool registry</name>
  <files>
    package.json
    src/index.js
    src/tools/registry.js
  </files>
  <action>
1. Install MCP SDK:
   ```
   npm install @modelcontextprotocol/sdk@^1.25.3
   ```
   If npm warns about zod peer dependency, install it too: `npm install zod@^4.3.6`

2. Update package.json scripts:
   - Add `"start": "node src/index.js"` to scripts

3. Create `src/index.js` following the EXACT pattern from the user's n8n-mcp-server and epistemic-mcp:
   - Import `Server` from `@modelcontextprotocol/sdk/server/index.js`
   - Import `StdioServerTransport` from `@modelcontextprotocol/sdk/server/stdio.js`
   - Import `CallToolRequestSchema`, `ListToolsRequestSchema` from `@modelcontextprotocol/sdk/types.js`
   - Import `getToolDefinitions`, `handleToolCall` from `./tools/registry.js`
   - Create Server instance: `new Server({ name: "paranoid-ableton", version: "0.1.0" }, { capabilities: { tools: {} } })`
   - Register ListToolsRequestSchema handler: return `{ tools: getToolDefinitions() }`
   - Register CallToolRequestSchema handler: extract `name` and `arguments` from `request.params`, call `handleToolCall(name, args)` and return result
   - `main()` function: create StdioServerTransport, call `server.connect(transport)`, log to stderr (NOT stdout -- stdout is the MCP protocol channel)
   - Catch fatal errors, log to stderr, exit(1)
   - CRITICAL: Zero console.log() calls anywhere. All logging via console.error() to stderr.

4. Create `src/tools/registry.js`:
   - Import `* as health` from `./health.js`
   - Create `modules` array: `[health]` (Phase 3+ adds transport, tracks, mixer, etc.)
   - Export `getToolDefinitions()`: `modules.flatMap(m => m.tools)`
   - Export `handleToolCall(name, args)`: iterate modules, call `mod.handle(name, args)`, return first non-null result. If no module handles the tool, return `{ content: [{ type: "text", text: "UNKNOWN_TOOL: No handler for tool '${name}'" }], isError: true }`
   - Add startup validation in `getToolDefinitions()`: check for duplicate tool names across modules. If duplicates found, log warning to stderr.
  </action>
  <verify>
    Run `node --check src/index.js` and `node --check src/tools/registry.js` -- both must pass syntax check.
    Run `node -e "import('./src/tools/registry.js').then(m => console.log(typeof m.getToolDefinitions, typeof m.handleToolCall))"` -- must print "function function".
  </verify>
  <done>
    - package.json has @modelcontextprotocol/sdk dependency and start script
    - src/index.js follows the low-level Server + setRequestHandler pattern matching user's existing MCP servers
    - src/tools/registry.js exports getToolDefinitions and handleToolCall with module aggregation pattern
    - Zero console.log calls (all stderr)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lazy OscClient singleton and ableton_status health tool</name>
  <files>
    src/tools/shared.js
    src/tools/health.js
  </files>
  <action>
1. Create `src/tools/shared.js` -- lazy OscClient singleton:
   - Import `OscClient` from `../osc-client.js`
   - Module-level variable: `let oscClient = null`
   - Export `getOscClient()`: if `oscClient` is null, create `new OscClient()` and store it. Return `oscClient`. This does NOT call `open()` -- just creates the instance.
   - Export `ensureConnected()`: call `getOscClient()`, if `!client.isReady` then `await client.open()`, return client. This is what tool handlers call.
   - Export `resetClient()`: set `oscClient = null`. This is for testing only (allows injecting mocks).
   - IMPORTANT: The OscClient is NOT created at import time. It is created on first call to `getOscClient()`. This ensures the MCP server starts cleanly even if Ableton is not running.

2. Create `src/tools/health.js` -- ableton_status tool:
   - Import `getOscClient`, `ensureConnected` from `./shared.js`
   - Export `tools` array with one tool definition:
     ```
     {
       name: "ableton_status",
       description: "Check Ableton Live connectivity and return connection status. Call this before starting a session to verify Ableton is reachable.",
       inputSchema: {
         type: "object",
         properties: {},
         required: []
       }
     }
     ```
   - Export `async handle(name, args)`:
     - If `name !== 'ableton_status'`, return `null` (not our tool)
     - Try:
       - `const client = await ensureConnected()` (lazy open)
       - `const healthy = await client.healthCheck()`
       - If healthy: return success response with JSON content: `{ connected: true, host: client.host, sendPort: client.sendPort, receivePort: client.receivePort }`
       - If not healthy: return `{ content: [{ type: "text", text: "CONNECTION_FAILED: Ableton not reachable on port {sendPort}. Ensure Ableton Live is running with AbletonOSC." }], isError: true }`
     - Catch errors:
       - Call `client.classifyError(err)` if client exists, otherwise classify manually
       - Map OscClient error types to MCP error codes:
         - PORT_NOT_READY -> `CONNECTION_FAILED: OSC client not ready on port {sendPort}`
         - TIMEOUT -> `TIMEOUT: No response from Ableton within 3000ms`
         - PORT_IN_USE -> `PORT_CONFLICT: Port {receivePort} already in use`
         - UNKNOWN -> `INTERNAL_ERROR: {err.message}`
       - Return with `isError: true`
     - Error text format: `ERROR_CODE: concise context` (per user's locked decision -- short codes, not verbose troubleshooting guides)
     - Do NOT include raw OSC addresses in error messages (they are implementation details)
  </action>
  <verify>
    Run `node --check src/tools/shared.js` and `node --check src/tools/health.js` -- both must pass.
    Run `node -e "import('./src/tools/health.js').then(m => { console.log(m.tools[0].name); console.log(typeof m.handle); })"` -- must print "ableton_status" and "function".
    Run `node -e "import('./src/tools/registry.js').then(m => { const defs = m.getToolDefinitions(); console.log(defs.length, defs[0].name); })"` -- must print "1 ableton_status".
  </verify>
  <done>
    - src/tools/shared.js provides lazy OscClient singleton (not created until first call)
    - src/tools/health.js defines ableton_status tool with proper MCP response format
    - Health tool returns isError:true with short error codes on failure
    - Health tool maps OscClient error types to MCP error codes
    - Full pipeline wired: index.js -> registry.js -> health.js -> shared.js -> osc-client.js
  </done>
</task>

</tasks>

<verification>
1. `node --check src/index.js` passes (syntax valid)
2. `node --check src/tools/registry.js` passes
3. `node --check src/tools/shared.js` passes
4. `node --check src/tools/health.js` passes
5. `node -e "import('./src/tools/registry.js').then(m => console.log(m.getToolDefinitions().map(t => t.name)))"` prints `['ableton_status']`
6. No `console.log` calls in any src/ file (only console.error for stderr)
7. package.json has @modelcontextprotocol/sdk in dependencies and "start" script
</verification>

<success_criteria>
- MCP server entry point follows user's established low-level Server + setRequestHandler pattern
- Tool registry aggregates domain modules and is ready for Phase 3+ additions (just add to modules array)
- OscClient is lazy-initialized (server starts without Ableton)
- ableton_status tool is the sole health check mechanism
- Error responses use isError:true with short ERROR_CODE: context format
- Zero stdout pollution (all logging to stderr)
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-server-shell/02-01-SUMMARY.md`
</output>
