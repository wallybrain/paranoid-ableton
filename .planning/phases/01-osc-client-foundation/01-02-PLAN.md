---
phase: 01-osc-client-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - test/osc-client.test.js
  - scripts/smoke-test.js
autonomous: true

must_haves:
  truths:
    - "Unit tests verify query resolves with plain values when response arrives"
    - "Unit tests verify query rejects with timeout error when no response arrives"
    - "Unit tests verify same-address queries are serialized (second waits for first)"
    - "Unit tests verify classifyError returns correct type for each error condition"
    - "Unit tests verify inferType maps JS types to correct OSC type tags"
    - "Unit tests verify healthCheck returns true on 'ok' response and false on timeout"
    - "Smoke test script exercises real OSC communication when Ableton is running"
  artifacts:
    - path: "test/osc-client.test.js"
      provides: "Unit tests for OscClient with mocked UDP"
      min_lines: 80
    - path: "scripts/smoke-test.js"
      provides: "Manual integration test against live Ableton"
      min_lines: 30
  key_links:
    - from: "test/osc-client.test.js"
      to: "src/osc-client.js"
      via: "import { OscClient, TIMEOUTS }"
      pattern: "import.*OscClient.*from.*osc-client"
    - from: "scripts/smoke-test.js"
      to: "src/osc-client.js"
      via: "import { OscClient }"
      pattern: "import.*OscClient.*from.*osc-client"
---

<objective>
Write comprehensive unit tests for OscClient and create an integration smoke test script for manual validation against a live Ableton instance.

Purpose: Tests prove the OscClient behaves correctly without needing Ableton running. The smoke test provides a quick manual validation path when Ableton IS available.
Output: A passing test suite using Node.js built-in test runner, and a runnable smoke-test script.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-osc-client-foundation/01-RESEARCH.md
@.planning/phases/01-osc-client-foundation/01-01-SUMMARY.md
@src/osc-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for OscClient</name>
  <files>test/osc-client.test.js</files>
  <action>
Create test/osc-client.test.js using Node.js built-in test runner (node:test) and assertion library (node:assert).

**Testing strategy:** Mock the osc.UDPPort to avoid real UDP sockets. The mock needs to:
- Emit 'ready' event when open() is called
- Capture sent messages for assertion
- Allow simulating incoming messages to test handleMessage
- Allow simulating errors to test handleError

**Mock approach:** Create a minimal mock UDPPort class that extends EventEmitter from 'node:events'. The mock:
- Has open() that immediately emits 'ready'
- Has send(msg) that stores msg in a sentMessages array
- Has close() that does nothing
- Exposes a simulateMessage(msg) method that emits 'message' event
- Exposes a simulateError(err) method that emits 'error' event

To inject the mock, use one of these approaches (in order of preference):
1. If OscClient accepts a port factory/instance in constructor options, pass the mock directly
2. Otherwise, construct OscClient normally then replace this.udpPort with mock before calling open()

**Test cases (ALL required):**

describe('OscClient constructor'):
- test: creates instance with default ports (11001 send, 11000 receive)
- test: accepts custom port configuration
- test: initializes pendingRequests as empty Map
- test: isReady starts as false

describe('open()'):
- test: resolves when ready event fires
- test: sets isReady to true after open

describe('close()'):
- test: sets isReady to false
- test: rejects all pending requests with closing error
- test: clears pending request timeouts

describe('query()'):
- test: sends OSC message with correct address and typed args
- test: resolves with plain values (not metadata objects) when response arrives
- test: rejects with timeout error after configured timeout (use short timeout like 50ms for test speed)
- test: throws if port not ready (isReady = false)
- test: serializes same-address queries (second query waits for first to complete)
- test: allows parallel queries to DIFFERENT addresses

describe('inferType()'):
- test: integer number returns 'i'
- test: float number returns 'f'
- test: string returns 's'
- test: boolean true returns 'T'
- test: boolean false returns 'F'
- test: null returns 'N'

describe('classifyError()'):
- test: returns PORT_NOT_READY when isReady is false
- test: returns TIMEOUT when error message contains 'timeout'
- test: returns PORT_IN_USE when error has EADDRINUSE
- test: returns UNKNOWN for unrecognized errors
- test: all error types have message and recoverable fields

describe('healthCheck()'):
- test: returns true when /live/test response is 'ok'
- test: returns false when query times out

describe('ensureConnected()'):
- test: resolves when healthCheck returns true
- test: throws descriptive error when healthCheck returns false

**Important notes:**
- Use `import { describe, it, beforeEach, afterEach, mock } from 'node:test'`
- Use `import assert from 'node:assert/strict'`
- Keep test timeouts short (50-100ms) so tests run fast
- Use beforeEach to create fresh OscClient + mock for each test
- Clean up after each test (close client, clear mocks)
  </action>
  <verify>
Run: `node --test test/osc-client.test.js`
Expected: All tests pass. Zero failures.
  </verify>
  <done>All unit tests pass. Tests cover: construction, open/close lifecycle, query resolution and timeout, same-address serialization, parallel different-address queries, type inference, error classification, health check success and failure, ensureConnected success and failure.</done>
</task>

<task type="auto">
  <name>Task 2: Integration smoke test script</name>
  <files>scripts/smoke-test.js</files>
  <action>
Create scripts/smoke-test.js as a runnable script for manual validation against a live Ableton instance.

The script should:

1. Print a header explaining what it does and prerequisites (Ableton running, AbletonOSC enabled)

2. Create an OscClient with default ports

3. Try to open the port, catch EADDRINUSE and print helpful error

4. Run health check:
   - If passes: print "Connected to Ableton Live via AbletonOSC"
   - If fails: print troubleshooting steps and exit

5. If connected, run a series of read-only queries (safe, no modifications to session):
   - Query tempo: `/live/song/get/tempo`
   - Query track count: `/live/song/get/num_tracks`
   - Query track 0 name: `/live/track/get/name` with arg [0]
   - Query is_playing: `/live/song/get/is_playing`

6. Print results in a formatted table

7. Close the client cleanly

8. Print summary: "N/N queries succeeded" or "N/N queries failed"

**Error handling:** Each query should be wrapped in try/catch so one failure doesn't stop the script. Print failures inline with error type from classifyError().

**Exit codes:** Exit 0 if health check + all queries pass. Exit 1 if health check fails. Exit 2 if some queries fail.

**Important:** This script is NOT a test -- it requires a live Ableton instance. It exists purely for manual validation. The script should print clear output suitable for pasting into a verification report.
  </action>
  <verify>
Run: `node --check scripts/smoke-test.js` exits 0 (syntax valid).
Run: `node scripts/smoke-test.js` -- if Ableton is not running, should print clear error message and exit 1 (not crash with unhandled rejection).
  </verify>
  <done>scripts/smoke-test.js runs without syntax errors. When Ableton is not available, it prints clear troubleshooting guidance and exits cleanly. When Ableton IS available, it queries tempo, track count, track name, and play state, printing formatted results.</done>
</task>

</tasks>

<verification>
1. `node --test test/osc-client.test.js` -- all tests pass with zero failures
2. `node --check scripts/smoke-test.js` -- exits 0 (no syntax errors)
3. `node scripts/smoke-test.js` -- exits cleanly with helpful message (Ableton not required for CI)
4. Test coverage includes: query resolve, query timeout, same-address serialization, type inference for all types, error classification for all types, healthCheck true/false, ensureConnected success/failure
</verification>

<success_criteria>
- All unit tests pass using `node --test`
- Tests mock UDP layer without requiring real network
- Tests verify query returns plain values (not metadata objects)
- Tests verify per-address serialization behavior
- Tests verify all 4 error classification types
- Smoke test runs cleanly whether or not Ableton is available
- Smoke test queries are read-only (safe to run against any session)
</success_criteria>

<output>
After completion, create `.planning/phases/01-osc-client-foundation/01-02-SUMMARY.md`
</output>
