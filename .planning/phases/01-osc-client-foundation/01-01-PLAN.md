---
phase: 01-osc-client-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .gitignore
  - .env.example
  - src/osc-client.js
autonomous: true

must_haves:
  truths:
    - "OscClient can open a UDP port on 11000 and target Ableton on 11001"
    - "query() sends an OSC message and returns a Promise that resolves with response args"
    - "Concurrent queries to the same address are serialized (second query waits or throws)"
    - "Queries that receive no response reject with a timeout error after the configured duration"
    - "healthCheck() sends /live/test and resolves true if response is 'ok'"
    - "classifyError() distinguishes PORT_NOT_READY, TIMEOUT, PORT_IN_USE, and UNKNOWN"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with osc dependency and ES module config"
      contains: "osc"
    - path: "src/osc-client.js"
      provides: "OscClient class with query, healthCheck, classifyError, open, close"
      exports: ["OscClient", "TIMEOUTS"]
      min_lines: 100
  key_links:
    - from: "src/osc-client.js"
      to: "osc"
      via: "import osc from 'osc'"
      pattern: "import osc from ['\"]osc['\"]"
    - from: "src/osc-client.js"
      to: "osc.UDPPort"
      via: "new osc.UDPPort constructor"
      pattern: "new osc\\.UDPPort"
    - from: "src/osc-client.js"
      to: "pendingRequests Map"
      via: "query stores promise, handleMessage resolves it"
      pattern: "this\\.pendingRequests\\.(set|get|delete)"
---

<objective>
Initialize the paranoid-ableton project and implement the core OscClient class that handles all UDP communication with AbletonOSC.

Purpose: This is the foundation layer for the entire project. Every subsequent phase (MCP server, controllers, MIDI editing, device control) depends on reliable OSC communication with request-response correlation.
Output: A working Node.js project with an OscClient class that can send OSC messages to AbletonOSC (port 11001), receive responses (port 11000), correlate them via address patterns, handle timeouts with context-aware durations, classify errors, and perform health checks.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-osc-client-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project scaffolding</name>
  <files>package.json, .gitignore, .env.example</files>
  <action>
Create the Node.js project at /home/user/ableton-mcp/:

1. Run `npm init -y` to create package.json, then modify it:
   - Set "name": "paranoid-ableton"
   - Set "type": "module" (ES modules, consistent with user's other MCP servers)
   - Set "version": "0.1.0"
   - Set "description": "MCP server for Claude to Ableton Live 12 control via AbletonOSC"
   - Set "main": "src/index.js"
   - Add scripts: "test": "node --test test/*.test.js", "smoke": "node scripts/smoke-test.js"
   - Set "private": true

2. Run `npm install osc@2.4.5` (exact version from research)

3. Create .gitignore with: node_modules/, .env, *.log, .DS_Store

4. Create .env.example with:
   - OSC_SEND_PORT=11001
   - OSC_RECEIVE_PORT=11000
   - OSC_HOST=127.0.0.1
   - LOG_LEVEL=info

5. Create empty directories: src/, test/, scripts/

Do NOT install a test framework. Node.js v20 has built-in `node:test` and `node:assert` which is sufficient and keeps dependencies minimal.
  </action>
  <verify>
Run: `node -e "import('./package.json', { assert: { type: 'json' } }).then(m => { const p = m.default; console.log(p.name, p.type, Object.keys(p.dependencies)); })"`
Expected: "paranoid-ableton module ['osc']"
Also verify: `ls src/ test/ scripts/` shows empty directories
  </verify>
  <done>package.json exists with type:module, osc@2.4.5 in dependencies, .gitignore and .env.example exist, src/test/scripts directories exist</done>
</task>

<task type="auto">
  <name>Task 2: Implement OscClient class</name>
  <files>src/osc-client.js</files>
  <action>
Create src/osc-client.js implementing the OscClient class per the research patterns. The class must handle ALL of these concerns:

**Exports:** Named exports for `OscClient` class and `TIMEOUTS` constant object.

**TIMEOUTS constant:**
```
QUERY: 5000, COMMAND: 7000, LOAD_DEVICE: 10000, LOAD_SAMPLE: 10000, HEALTH_CHECK: 3000
```

**Constructor(options = {}):**
- Accept optional `sendPort` (default 11001), `receivePort` (default 11000), `host` (default '127.0.0.1')
- Create `this.pendingRequests = new Map()` for address-based correlation
- Create `this.listeners = new Map()` for future Phase 7 listener support (just the Map, no implementation needed)
- Create `this.isReady = false` flag
- Create `this.udpPort` as new osc.UDPPort with:
  - localAddress: host, localPort: receivePort
  - remoteAddress: host, remotePort: sendPort
  - metadata: true (CRITICAL per research -- without this, type parsing breaks)
- Wire up event handlers: message -> handleMessage, error -> handleError, ready -> set isReady=true

**open():**
- Call this.udpPort.open()
- Return a Promise that resolves when 'ready' fires (or immediately if already ready)
- Must handle the case where open() fails with EADDRINUSE

**close():**
- Clear all pending request timeouts
- Reject all pending requests with "Client closing" error
- Close the UDP port
- Set isReady = false

**query(address, args = [], timeout = TIMEOUTS.QUERY):**
- If !this.isReady, throw immediately (don't send into void)
- If this.pendingRequests.has(address), QUEUE the request (don't throw -- use a simple approach: await the existing pending request to complete, then send ours). Implementation: create a chain per address using a separate `this.requestQueues` Map that stores a promise chain per address. Each new query for the same address chains onto the previous.
- Create a new Promise with setTimeout for rejection
- Store { resolve, reject, timeoutId } in pendingRequests keyed by address
- Send OSC message via this.udpPort.send() with args mapped through inferType()
- Return the promise
- On resolve: extract values from metadata args (return array of plain values, not {type, value} objects)

**handleMessage(msg):**
- Check pendingRequests for msg.address
- If found: clearTimeout, delete from map, resolve with args (plain values extracted from metadata)
- If not found: check listeners map, call listener callback if exists
- If neither: log at debug level and discard

**inferType(val):**
- number + isInteger -> 'i'
- number + !isInteger -> 'f'
- string -> 's'
- boolean true -> 'T', false -> 'F'
- null/undefined -> 'N' (OSC Nil)
- Default: 's'

**handleError(err):**
- Run classifyError on the error
- If PORT_IN_USE: log clear message about port conflict
- Store last error for retrieval

**classifyError(err):**
- Return object { type, message, recoverable }
- Types: PORT_NOT_READY (isReady false), TIMEOUT (message includes 'timeout'), PORT_IN_USE (EADDRINUSE), UNKNOWN
- Each type has a helpful human-readable message (see research for exact messages)

**healthCheck():**
- Call query('/live/test', [], TIMEOUTS.HEALTH_CHECK)
- Return true if response first value === 'ok'
- Catch errors and return false

**ensureConnected():**
- Call healthCheck()
- If false, throw with clear message listing troubleshooting steps

**IMPORTANT DESIGN DECISIONS:**
- Return plain values from query(), not metadata objects. Callers should get `[120.0]` not `[{type:'f', value:120.0}]`. This simplifies all downstream code.
- Queue same-address queries rather than throwing. Throwing forces callers to implement retry logic. Queuing is transparent.
- Port numbers should respect environment variables: process.env.OSC_SEND_PORT, process.env.OSC_RECEIVE_PORT, process.env.OSC_HOST (with fallback defaults).
  </action>
  <verify>
Run: `node -e "import { OscClient, TIMEOUTS } from './src/osc-client.js'; console.log('OscClient:', typeof OscClient); console.log('TIMEOUTS:', JSON.stringify(TIMEOUTS));"`
Expected: OscClient is a function/class, TIMEOUTS has QUERY/COMMAND/LOAD_DEVICE/LOAD_SAMPLE/HEALTH_CHECK keys with correct values.

Also verify static analysis: `node --check src/osc-client.js` should exit 0 (no syntax errors).
  </verify>
  <done>src/osc-client.js exports OscClient class and TIMEOUTS constant. Class has constructor, open, close, query (with per-address queuing), handleMessage, handleError, classifyError, healthCheck, ensureConnected, inferType methods. metadata:true is set on UDPPort. Port numbers are configurable via constructor and env vars.</done>
</task>

</tasks>

<verification>
1. `node --check src/osc-client.js` exits 0
2. `node -e "import { OscClient, TIMEOUTS } from './src/osc-client.js'; const c = new OscClient(); console.log('constructed ok');"` prints "constructed ok" (no errors on construction without opening)
3. TIMEOUTS object has 5 keys with correct millisecond values
4. package.json has "type": "module" and osc@2.4.5 dependency
5. .gitignore exists with node_modules
6. .env.example exists with port configuration
</verification>

<success_criteria>
- Project initializes as ES module Node.js project with osc@2.4.5 dependency
- OscClient class can be imported and constructed without errors
- All required methods exist on OscClient prototype
- TIMEOUTS constant is exported with 5 context-aware timeout values
- Code uses metadata:true on UDPPort for type-safe message parsing
- query() method implements per-address queuing (not throwing on duplicate addresses)
- classifyError() returns structured objects with type, message, recoverable fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-osc-client-foundation/01-01-SUMMARY.md`
</output>
